import GroupoidModel.Groupoids.Sigma
import GroupoidModel.Syntax.NaturalModel
import GroupoidModel.ForMathlib.CategoryTheory.Whiskering
import GroupoidModel.ForMathlib.CategoryTheory.NatTrans

universe v u v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ

noncomputable section
-- NOTE temporary section for stuff to be moved elsewhere
section ForOther
namespace CategoryTheory

namespace ObjectProperty

-- JH: after the golfs, we don't acuse this lemma anymore,
-- but it is still probably useful?
lemma Œπ_mono {T C : Type u} [Category.{v} C] [Category.{v} T]
    {Z : C ‚Üí Prop} (f g : T ‚•§ FullSubcategory Z)
    (e : f ‚ãô Œπ Z = g ‚ãô Œπ Z) : f = g := by
  apply CategoryTheory.Functor.ext_of_iso _ _ _
  ¬∑ exact Functor.fullyFaithfulCancelRight (Œπ Z) (eqToIso e)
  ¬∑ intro X
    ext
    exact Functor.congr_obj e X
  ¬∑ intro X
    simp only [Functor.fullyFaithfulCancelRight_hom_app, Functor.preimage, Œπ_obj, Œπ_map,
      eqToIso.hom, eqToHom_app, Functor.comp_obj, Classical.choose_eq]
    rfl


end ObjectProperty

instance {C : Type*} [Groupoid C] (P : ObjectProperty C) :
    Groupoid (P.FullSubcategory) :=
  InducedCategory.groupoid C (ObjectProperty.Œπ _).obj

instance Grpd.Œπ_mono (G : Grpd) (P : ObjectProperty G) : Mono (Grpd.homOf (ObjectProperty.Œπ P)) :=
  ‚ü® fun _ _ e => ObjectProperty.Œπ_mono _ _ e ‚ü©

end CategoryTheory

end ForOther

-- NOTE content for this doc starts here
namespace GroupoidModel

open CategoryTheory NaturalModelBase Opposite Grothendieck.Groupoidal  Groupoid

attribute [local simp] eqToHom_map Grpd.id_eq_id Grpd.comp_eq_comp Functor.id_comp Functor.comp_id


-- @yiming can we remove this?
/-
   Uncomment this to see the the flow of organizing Conjugation into the Conjugating functor.
   def Conjugating0 {Œì : Grpd.{v,u}} (A B : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ})
    {x y: Œì } (f: x ‚ü∂ y) : (A.obj x‚•§ B.obj x) ‚•§ (A.obj y‚•§ B.obj y) :=
     let wr : B.obj x ‚•§ B.obj y := B.map f
     let wl : A.obj y ‚•§ A.obj x := A.map (Groupoid.inv f)
     let f1_ty : (A.obj y ‚•§ A.obj x) ‚•§ ((A.obj x) ‚•§ (B.obj x)) ‚•§ (A.obj y) ‚•§  (B.obj x) :=
       whiskeringLeft (A.obj y) (A.obj x) (B.obj x)
     let f1 : ((A.obj x) ‚•§ (B.obj x)) ‚•§ (A.obj y) ‚•§  (B.obj x) :=
       (whiskeringLeft (A.obj y) (A.obj x) (B.obj x)).obj (A.map (Groupoid.inv f))
     let f2_ty :  ((B.obj x) ‚•§ (B.obj y)) ‚•§ (A.obj y ‚•§ B.obj x) ‚•§ (A.obj y) ‚•§  (B.obj y) :=
       whiskeringRight (A.obj y) (B.obj x) (B.obj y)
     let f2 : (A.obj y ‚•§ B.obj x) ‚•§ (A.obj y) ‚•§  (B.obj y) :=
       (whiskeringRight (A.obj y) (B.obj x) (B.obj y)).obj (B.map f)
     let f3 := f1 ‚ãô f2
     f3
-/

namespace FunctorOperation
section

open CategoryTheory.Functor

variable {Œì : Type u} [Groupoid.{v} Œì] (A B : Œì ‚•§ Grpd)

/--
The functor that, on objects `G : A.obj x ‚•§ B.obj x` acts by
creating the map on the right,
by taking the inverse of `f : x ‚ü∂ y` in the groupoid
         A f
  A x --------> A y
   |             .
   |             |
   |             .
G  |             | conjugating A B f G
   |             .
   V             V
  B x --------> B y
         B f
-/
def conjugating {x y : Œì} (f : x ‚ü∂ y) : (A.obj x ‚•§ B.obj x) ‚•§ (A.obj y ‚•§ B.obj y) :=
  whiskeringLeftObjWhiskeringRightObj (A.map (CategoryTheory.inv f)) (B.map f)

@[simp] lemma conjugating_obj {x y : Œì} (f : x ‚ü∂ y) (s : A.obj x ‚•§ B.obj x) :
    (conjugating A B f).obj s = CategoryTheory.inv (A.map f) ‚ãô s ‚ãô B.map f := by
  simp [conjugating]

@[simp] lemma conjugating_map {x y : Œì} (f : x ‚ü∂ y) {s1 s2 : A.obj x ‚•§ B.obj x} (h : s1 ‚ü∂ s2) :
    (conjugating A B f).map h
    = whiskerRight (whiskerLeft (A.map (CategoryTheory.inv f)) h) (B.map f) := by
  simp [conjugating]

@[simp] lemma conjugating_id (x : Œì) : conjugating A B (ùüô x) = ùü≠ _ := by
  simp [conjugating]

@[simp] lemma conjugating_comp (x y z : Œì) (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    conjugating A B (f ‚â´ g) = conjugating A B f ‚ãô conjugating A B g := by
  simp [conjugating]

@[simp] lemma conjugating_naturality_map {Œî : Type u‚ÇÅ} [Groupoid.{v‚ÇÅ} Œî] (œÉ : Œî ‚•§ Œì)
    {x y} (f : x ‚ü∂ y) : conjugating (œÉ ‚ãô A) (œÉ ‚ãô B) f = conjugating A B (œÉ.map f) := by
  simp [conjugating]
end

section
variable {A B : Type*} [Category A] [Category B] (F : B ‚•§ A)

-- NOTE to follow mathlib convention can use camelCase for definitions, and capitalised first letter when that definition is a Prop or Type
def IsSection (s : A ‚•§ B) := s ‚ãô F = Functor.id A

abbrev Section := ObjectProperty.FullSubcategory (IsSection F)

instance Section.category : Category (Section F) :=
  ObjectProperty.FullSubcategory.category (IsSection F)

abbrev Section.Œπ : Section F ‚•§ (A ‚•§ B) :=
  ObjectProperty.Œπ (IsSection F)

end

section

variable {Œì : Type*} [Category Œì] {A : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}}
  (B : ‚à´(A) ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}) (x : Œì)

abbrev sigma.fstAuxObj : sigmaObj B x ‚•§ A.obj x := forget

open sigma

def piObj : Type _ := Section (fstAuxObj B x)

instance piObj.groupoid : Groupoid (piObj B x) :=
  inferInstanceAs (Groupoid (Section (fstAuxObj B x)))

end

section
variable {Œì : Type*} [Groupoid Œì] (A : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ}) (B : ‚à´(A) ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ})
variable {x y: Œì} (f: x ‚ü∂ y)

open sigma

/--
If `s : piObj B x` then the underlying functor is of the form `s : A x ‚•§ sigma A B x`
and it is a section of the forgetful functor `sigma A B x ‚•§ A x`.
This theorem states that conjugating `A f‚Åª¬π ‚ãô s ‚ãô sigma A B f‚Åª¬π : A y ‚•§ sigma A B y`
using some `f : x ‚ü∂ y` produces a section of the forgetful functor `sigma A B y ‚•§ A y`.
-/
theorem isSection_conjugating_isSection (s : piObj B x) : IsSection (fstAuxObj B y)
    ((Section.Œπ (fstAuxObj B x) ‚ãô conjugating A (sigma A B) f).obj s) := by
  simp only [IsSection, Functor.comp_obj, ObjectProperty.Œπ_obj,
    conjugating_obj, Functor.assoc]
  convert_to CategoryTheory.inv (A.map f) ‚ãô (s.obj ‚ãô fstAuxObj B x) ‚ãô A.map f = _
  rw [s.property]
  simp only [Functor.id_comp, ‚Üê Grpd.comp_eq_comp, IsIso.inv_hom_id, Grpd.id_eq_id]

/-- The functorial action of `pi` on a morphism `f : x ‚ü∂ y` in `Œì`
is given by "conjugation".
Since `piObj B x` is a full subcategory of `sigma A B x ‚•§ A x`,
we obtain the action `piMap : piObj B x ‚•§ piObj B y`
as the induced map in the following diagram
          the inclusion
           Section.Œπ
   piObj B x   ‚•§   (A x ‚•§ sigma A B x)
     ‚ãÆ                     ||
     ‚ãÆ                     || conjugating A (sigma A B) f
     VV                     VV
   piObj B y   ‚•§   (A y ‚•§ sigma A B y)
-/
def piMap : piObj B x ‚•§ piObj B y :=
  ObjectProperty.lift (IsSection (fstAuxObj B y))
  ((Section.Œπ (fstAuxObj B x) ‚ãô conjugating A (sigma A B) f))
  (isSection_conjugating_isSection A B f)

lemma piMap_obj_obj (s: piObj B x) : ((piMap A B f).obj s).obj =
    (conjugating A (sigma A B) f).obj s.obj := rfl

lemma piMap_map (s1 s2: piObj B x) (Œ∑: s1 ‚ü∂ s2) :
    (piMap A B f).map Œ∑ = (conjugating A (sigma A B) f).map Œ∑ :=
  rfl

/--
The square commutes

   piObj B x   ‚•§   (A x ‚•§ sigma A B x)
     ‚ãÆ                     ||
piMap‚ãÆ                     || conjugating A (sigma A B) f
     VV                     VV
   piObj B y   ‚•§   (A y ‚•§ sigma A B y)
-/
lemma piMap_Œπ : piMap A B f ‚ãô Section.Œπ (fstAuxObj B y)
    = Section.Œπ (fstAuxObj B x) ‚ãô conjugating A (sigma A B) f :=
  rfl

@[simp] lemma piMap_id (x : Œì) : piMap A B (ùüô x) = ùü≠ (piObj B x) := by
  simp only [piMap, conjugating_id]
  rfl

lemma piMap_comp {x y z : Œì} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    piMap A B (f ‚â´ g) = (piMap A B f) ‚ãô (piMap A B g) := by
  simp only [piMap, conjugating_comp]
  rfl

/-- The formation rule for Œ†-types for the natural model `smallU`
  as operations between functors -/
@[simps] def pi : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ} where
  obj x := Grpd.of $ piObj B x
  map := piMap A B
  map_id := piMap_id A B
  map_comp := piMap_comp A B

end




section

variable {Œì : Type*} [Groupoid Œì] (A : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ}) (B : ‚à´(A) ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ})

{Œî : Type*} [Groupoid Œî] (œÉ : Œî ‚•§ Œì)

theorem IsSection_eq (x) : sigma.fstAuxObj B (œÉ.obj x)
    ‚âç sigma.fstAuxObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x := by
  dsimp [sigma.fstAuxObj]
  rw [sigma_naturality_aux]

theorem pi_naturality_obj (x) :
    (œÉ ‚ãô pi A B).obj x = (pi (œÉ ‚ãô A) (pre A œÉ ‚ãô B)).obj x := by
  dsimp [pi, piObj, sigma.fstAuxObj, piObj.groupoid]
  rw [sigma_naturality_aux]

lemma piObj_naturality (x):
  piObj B (œÉ.obj x) = piObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x := by
  dsimp [pi, piObj, sigma.fstAuxObj, piObj.groupoid]
  rw [sigma_naturality_aux]




lemma eqToHom_eq_homOf_map' {Œì : Type*} [Groupoid Œì] {F G : Œì ‚•§ Grpd} (h : F = G) :
    eqToHom (by rw [h]) = Grpd.homOf (map (eqToHom h)) := by
  subst h
  fapply CategoryTheory.Functor.ext
  ¬∑ intro x
    apply obj_hext
    ¬∑ simp
    ¬∑ simp
  ¬∑ intro x y f
    rw! [Grothendieck.Groupoidal.map_id_eq]
    simp


    /-
    Œî ------pi (œÉ ‚ãô A) (pre A œÉ ‚ãô B)-------> Grpd
    |                                           |
    |                                           |
    œÉ                                           |
    |                                           |
    v                                           v
    Œì -------pi A B -------------------------> Grpd

    -/
section

variables {C D E F: Type u} [Category.{v,u} C] [Category.{v,u} D] [Category.{v,u} E] [Category F]

-- def eqToFuncHom (e1 : C = E) (e2 : D = F) : (C ‚•§ D) = (E ‚•§ F) := by

--   sorry

-- lemma cast_id (e: C) (h: C = E): HEq ((h ‚ñ∏ ùüô E) e) (cast h e) := sorry


-- def eqToFunc (e1 : C = E) : (C ‚•§ E) where
--   obj := by
--     simp[e1]
--     exact ùüô E
--   map {x y} f:= by
--     simp[cast, CategoryTheory.congrArg_cast_hom_left]
--     apply f
--     sorry
--   map_id := sorry
--   map_comp := sorry

-- def eqToFuncHom' (e1 : C = E) (e2 : D = F) : (C ‚•§ D) ‚•§  (E ‚•§ F) :=
--   eqToHom (eqToFuncHom e1 e2)

-- theorem comp_eqToHom_iff {X Y Y' : C ‚•§ E} (p : Y = Y') (f : X ‚ü∂ Y) (g : X ‚ü∂ Y') :
--     f ‚ãô eqToHom p = g ‚Üî f = g ‚â´  eqToHom p.symm := sorry



end



variable (x y : Œî )
lemma comp_obj_eq (x): A.obj (œÉ.obj x) = (œÉ ‚ãô A).obj x := rfl
#check GroupoidModel.FunctorOperation.IsSection
#check map (eqToHom  (sigma_naturality_aux B œÉ y))
#check  CategoryTheory.ObjectProperty.FullSubcategory.lift_comp_inclusion_eq

def funcEqWhisker1 (x) : (((œÉ ‚ãô A).obj x) ‚•§ sigmaObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x)‚•§
    (A.obj (œÉ.obj x)) ‚•§ sigmaObj B (œÉ.obj x) :=
    (CategoryTheory.Functor.whiskeringRight _ _ _ ).obj
    (map (eqToHom (sigma_naturality_aux B œÉ x)))





-- lemma eqToHom_Œπ1 {x } :
--  eqToHom (pi_naturality_obj A B Œî œÉ x).symm ‚ãô
--  ObjectProperty.Œπ (IsSection (sigma.fstAuxObj B (œÉ.obj x))) =
--  ObjectProperty.Œπ (IsSection (sigma.fstAuxObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x)) ‚ãô
--  funcEqWhisker1 A B Œî œÉ  (x) :=



--  sorry

lemma eqToHom_Œπ_aux :
    Grpd.of ((A.obj (œÉ.obj x)) ‚•§ ‚à´(Œπ A (œÉ.obj x) ‚ãô B))
    = Grpd.of (A.obj (œÉ.obj x) ‚•§ ‚à´(Œπ (œÉ ‚ãô A) x ‚ãô pre A œÉ ‚ãô B)) :=
  by rw [sigma_naturality_aux]

lemma ObjectProperty.eqToHom_comp_Œπ {C D : Grpd} (h : C = D) (P : ObjectProperty C)
    (Q : ObjectProperty D) (hP : P ‚âç Q) :
    let h' : Grpd.of P.FullSubcategory = Grpd.of Q.FullSubcategory := by
      subst h hP; rfl
    eqToHom h' ‚ãô (ObjectProperty.Œπ Q) = (ObjectProperty.Œπ P) ‚ãô eqToHom h := by
  subst h hP; rfl

lemma eqToHom_Œπ (x) :
    eqToHom (pi_naturality_obj A B œÉ x) ‚ãô
    ObjectProperty.Œπ (IsSection (sigma.fstAuxObj (pre A œÉ ‚ãô B) x)) =
    ObjectProperty.Œπ (IsSection (sigma.fstAuxObj B (œÉ.obj x))) ‚ãô
    eqToHom (eqToHom_Œπ_aux A B œÉ x) := by
  apply ObjectProperty.eqToHom_comp_Œπ (eqToHom_Œπ_aux A B œÉ x)
  dsimp [sigma.fstAuxObj, piObj.groupoid]
  rw [sigma_naturality_aux]

def funcEqWhisker :
    ((A.obj (œÉ.obj x)) ‚•§ ‚à´(Œπ A (œÉ.obj x) ‚ãô B)) -- parentheses here
    ‚•§ (A.obj (œÉ.obj x)) ‚•§ ‚à´(Œπ (œÉ ‚ãô A) x ‚ãô pre A œÉ ‚ãô B) :=
    (Functor.whiskeringRight (A.obj (œÉ.obj x)) (‚à´(Œπ A (œÉ.obj x) ‚ãô B)) ‚à´(Œπ (œÉ ‚ãô A) x ‚ãô pre A œÉ ‚ãô B)).obj
     (map (eqToHom (sigma_naturality_aux B œÉ x).symm))

-- def funcEqWhisker0 (x) :
--     ((A.obj (œÉ.obj x)) ‚•§ ‚à´(Œπ A (œÉ.obj x) ‚ãô B)) ‚•§
--     (((œÉ ‚ãô A).obj x) ‚•§ ‚à´(Œπ (œÉ ‚ãô A) x ‚ãô Grothendieck.Groupoidal.pre A œÉ ‚ãô B)) :=
--     (CategoryTheory.Functor.whiskeringRight (A.obj (œÉ.obj x)) (‚à´(Œπ A (œÉ.obj x) ‚ãô B))
--      (‚à´(Œπ (œÉ ‚ãô A) x ‚ãô Grothendieck.Groupoidal.pre A œÉ ‚ãô B) ) ).obj
--      (map (eqToHom (sigma_naturality_aux B œÉ x).symm))

-- lemma eqToHom_Œπ11 {x } :
--  eqToHom (pi_naturality_obj A B Œî œÉ x) ‚ãô
--  ObjectProperty.Œπ (IsSection (sigma.fstAuxObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x)) =
--  ObjectProperty.Œπ (IsSection (sigma.fstAuxObj B (œÉ.obj x))) ‚ãô
--  funcEqWhisker A B Œî œÉ  (x) := by
--  fapply CategoryTheory.Functor.ext
--  ¬∑ intro s
--    simp [funcEqWhisker, ‚Üê eqToHom_eq_homOf_map]

--    -- rw! [sigma_naturality_aux]
--   --  fapply CategoryTheory.Functor.ext
--   --  ¬∑ intro a
--   --    rw! (castMode := .all) [(sigma_naturality_aux B œÉ x)]
--   --    simp[map_id_eq]
--   --    congr!
--   --    ¬∑ sorry
--   --    simp[Cat.eqToHom_obj]

--    sorry


--  ¬∑ intro s1 s2 h
--    simp



--    sorry

section
variable  {C : Type u} [Category.{v} C]{D : Type u} [Category.{v} D] (P Q : ObjectProperty D)
  (F : C ‚•§ D) (hF : ‚àÄ X, P (F.obj X))

theorem FullSubcategory.lift_comp_inclusion_eq :
    P.lift F hF ‚ãô P.Œπ = F :=
  rfl

end

/-
theorem conj_eqToHom_iff_heq {W X Y Z : C} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) (h : W = Y) (h' : X = Z) :
    f = eqToHom h ‚â´ g ‚â´ eqToHom h'.symm ‚Üî HEq f g := by
  cases h
  cases h'
  simp

-/
section

variable {C1 C2 C3 C4: Type u} [Category C1]  [Category C2] [Category C3] [Category C4]
 (e: C1 = C2) (e' : C3 = C4) (G: C1 ‚•§ C3) (F: C2 ‚•§ C4)

-- lemma map_eqToHom_conj: map (eqToHom e) ‚ãô F = G ‚ãô map (eqToHom e') ‚Üî
--   map (eqToHom e) ‚ãô F ‚ãô map (eqToHom e'.symm) = G := sorry


end


-- lemma sigma_naturality_conj' {x y :Œî} (f: x‚ü∂ y):
-- sigmaMap B (œÉ.map f) =
--   eqToHom (sigma_naturality_obj B œÉ x) ‚â´
--   (sigma (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô B)).map f ‚â´
--   Grpd.homOf (map (eqToHom (sigma_naturality_aux B œÉ y))) := by
--   apply sigma_naturality_conj


/-

lemma funcEqWhisker_conjugating1 {x y} (f : x ‚ü∂ y) :
    funcEqWhisker A B Œî œÉ x
    ‚ãô conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô B)) f
    = conjugating A (sigma A B) (œÉ.map f) ‚ãô funcEqWhisker A B Œî œÉ y := by
  dsimp [funcEqWhisker]
  fapply CategoryTheory.Functor.ext
  ¬∑ intro s
    dsimp[sigmaMap,funcEqWhisker]
    simp[conjugating_obj,Functor.assoc]
    congr 2
    simp[sigma_naturality_conj',Functor.assoc]
    rw [eqToHom_eq_homOf_map (sigma_naturality_aux B œÉ x).symm]
    congr
    simp[Grpd.homOf,‚Üê map_comp_eq,map_id_eq]
  ¬∑ intro s1 s2 h
    rw[CategoryTheory.conj_eqToHom_iff_heq]
    ¬∑ sorry
    simp

    sorry
-- -/

-- lemma sigma_naturality_map' {x y : Œî} (f : x ‚ü∂ y) : sigmaMap B (œÉ.map f)
--     = (map (eqToHom (sigma_naturality_aux B œÉ x).symm)) ‚â´
--     (sigma (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô B)).map f ‚â´
--    (map (eqToHom (sigma_naturality_aux B œÉ y))) := by
--   have : pre (Œπ A (œÉ.obj y) ‚ãô B) (A.map (œÉ.map f))
--       = map (eqToHom (by rw[‚Üê (sigma_naturality_aux B œÉ y)]))
--       ‚ãô pre (Œπ (œÉ ‚ãô A) y ‚ãô pre A œÉ ‚ãô B) (A.map (œÉ.map f))
--       ‚ãô map (eqToHom (sigma_naturality_aux B œÉ y)) := by
--     rw [pre_congr_functor]
--   dsimp [Grpd.homOf, sigmaMap, ‚Üê Functor.assoc]
--   rw [‚Üê Grothendieck.Groupoidal.map_comp_eq, whiskerRight_ŒπNatTrans_naturality]
--   simp [Grothendieck.Groupoidal.map_comp_eq, this, Functor.assoc]


-- lemma funcEqWhisker_conjugating1 {x y} (f: x‚ü∂ y):
--  funcEqWhisker A B Œî œÉ x ‚ãô conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô B)) f =
--   conjugating A (sigma A B) (œÉ.map f) ‚ãô funcEqWhisker A B Œî œÉ y := by
--   dsimp[sigmaMap,funcEqWhisker,conjugating_comp,Functor.assoc]
--   fapply CategoryTheory.Functor.ext
--   ¬∑ simp? [sigma_naturality_map, Functor.assoc, ‚Üê map_comp_eq, map_id_eq]
--   ¬∑ intro s1 s2 h
--     rw[CategoryTheory.conj_eqToHom_iff_heq]
--     ¬∑
--       simp?[Functor.whiskerRight,Functor.whiskerLeft,sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]

--       congr!
--       ¬∑ simp[Functor.assoc]
--         congr!
--         simp[sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       ¬∑ simp[sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       --rw![sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]

--       simp only[‚Üê Functor.comp_map]
--       rw! (castMode := .all) [sigma_naturality_map]
--       simp
--       simp only[‚Üê Functor.comp_map]
--       congr!
--       ¬∑ simp[Functor.assoc]
--         congr!
--         simp[Grpd.homOf]
--         simp[ ‚Üê map_comp_eq,map_id_eq]
--       ¬∑ simp
--       ¬∑ simp
--       ¬∑ simp
--     simp [sigma_naturality_map, Functor.assoc, ‚Üê map_comp_eq, map_id_eq]

lemma eqToHom_conjugating {x y} (f : x ‚ü∂ y):
    eqToHom (eqToHom_Œπ_aux A B œÉ x) ‚â´ conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (pre A œÉ ‚ãô B)) f =
    conjugating A (sigma A B) (œÉ.map f) ‚â´ eqToHom (eqToHom_Œπ_aux A B œÉ y) := by
  conv => left; right; rw! (castMode := .all) [‚Üê sigma_naturality]
  simp only [Functor.comp_obj, conjugating_naturality_map]
  apply eq_of_heq
  rw [heq_comp_eqToHom_iff] -- HEq tactic please
  apply HEq.trans (eqToHom_comp_heq _ _)
  simp


-- lemma funcEqWhisker_conjugating {x y} (f: x‚ü∂ y):
--  funcEqWhisker A B Œî œÉ x ‚ãô conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô B)) f =
--   conjugating A (sigma A B) (œÉ.map f) ‚ãô funcEqWhisker A B Œî œÉ y := by
--   dsimp[sigmaMap,funcEqWhisker,conjugating_comp,Functor.assoc]
--   fapply CategoryTheory.Functor.ext
--   ¬∑ simp only [Functor.comp_obj, Functor.whiskeringRight_obj_obj, conjugating_obj, sigma_obj,
--       sigmaObj, Grpd.coe_of, Functor.comp_map, sigma_map, Functor.assoc, sigma_naturality_map,
--       Grpd.comp_eq_comp, ‚Üê map_comp_eq, eqToHom_trans, eqToHom_refl, map_id_eq, Cat.of_Œ±,
--       Functor.comp_id, implies_true]
--   ¬∑ intro s1 s2 h
--     -- rw[CategoryTheory.conj_eqToHom_iff_heq]
--     ¬∑
--       -- simp?[Functor.whiskerRight,Functor.whiskerLeft]
--       sorry
--       -- congr!
--       -- ¬∑ simp[Functor.assoc]
--       --   congr!
--       --   simp[sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       -- ¬∑ simp[sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       -- --rw![sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]

--       -- simp only[‚Üê Functor.comp_map]
--       -- rw! (castMode := .all) [sigma_naturality_map]
--       -- simp
--       -- simp only[‚Üê Functor.comp_map]
--       -- congr!
--       -- ¬∑ simp[Functor.assoc]
--       --   congr!
--       --   simp[Grpd.homOf]
--       --   simp[ ‚Üê map_comp_eq,map_id_eq]
--       -- ¬∑ simp
--       -- ¬∑ simp
--       -- ¬∑ simp
--     -- ¬∑ simp [sigma_naturality_map, Functor.assoc, ‚Üê map_comp_eq, map_id_eq]


-- lemma funcEqWhisker_conjugating {x y} (f: x‚ü∂ y):
--  funcEqWhisker A B Œî œÉ x ‚ãô conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô B)) f =
--   conjugating A (sigma A B) (œÉ.map f) ‚ãô funcEqWhisker A B Œî œÉ y := by
--   dsimp[sigmaMap,funcEqWhisker,conjugating_comp,Functor.assoc]
--   fapply CategoryTheory.Functor.ext
--   ¬∑ simp? [sigma_naturality_map, Functor.assoc, ‚Üê map_comp_eq, map_id_eq]
--   ¬∑ intro s1 s2 h
--     rw[CategoryTheory.conj_eqToHom_iff_heq]
--     ¬∑
--       simp?[Functor.whiskerRight,Functor.whiskerLeft]

--       congr!
--       ¬∑ simp[Functor.assoc]
--         congr!
--         simp[sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       ¬∑ simp[sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       --rw![sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]

--       simp only[‚Üê Functor.comp_map]
--       rw! (castMode := .all) [sigma_naturality_map]
--       simp
--       simp only[‚Üê Functor.comp_map]
--       congr!
--       ¬∑ simp[Functor.assoc]
--         congr!
--         simp[Grpd.homOf]
--         simp[ ‚Üê map_comp_eq,map_id_eq]
--       ¬∑ simp
--       ¬∑ simp
--       ¬∑ simp
--     simp [sigma_naturality_map, Functor.assoc, ‚Üê map_comp_eq, map_id_eq]




-- lemma funcEqWhisker_conjugating {x y} (f: x‚ü∂ y):
--  funcEqWhisker A B Œî œÉ x ‚ãô conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô B)) f =
--   conjugating A (sigma A B) (œÉ.map f) ‚ãô funcEqWhisker A B Œî œÉ y := by
--   dsimp[sigmaMap,funcEqWhisker,conjugating_comp,Functor.assoc]
--   fapply CategoryTheory.Functor.ext
--   ¬∑ simp? [sigma_naturality_map, Functor.assoc, ‚Üê map_comp_eq, map_id_eq]
--   ¬∑ intro s1 s2 h
--     rw[CategoryTheory.conj_eqToHom_iff_heq]
--     ¬∑
--       simp?[Functor.whiskerRight,Functor.whiskerLeft]
--       congr!
--       ¬∑ simp[Functor.assoc]
--         congr!
--         simp[sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       ¬∑ simp[sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       --rw![sigma_naturality_map,Functor.assoc,‚Üê map_comp_eq, map_id_eq]
--       congr!
--       #check Functor.comp_map
--       simp only[‚Üê Functor.comp_map]
--       simp only[sigma_naturality_map]
--       --simp[‚Üê Functor.comp_map]
--       rw[sigma_naturality_map]
--       simp[map_inv]
--       conv => rhs;simp only[sigma_naturality_map]
--       sorry
--     simp [sigma_naturality_map, Functor.assoc, ‚Üê map_comp_eq, map_id_eq]

lemma comm_sq_of_comp_mono {C : Type*} [Category C]
    {X Y Z W X' Y' Z' W' : C}
    (f : X ‚ü∂ Y) (h : X ‚ü∂ W) (g : Y ‚ü∂ Z) (i : W ‚ü∂ Z)
    (f' : X' ‚ü∂ Y') (h' : X' ‚ü∂ W') (g' : Y' ‚ü∂ Z') (i' : W' ‚ü∂ Z')
    (mX : X ‚ü∂ X') (mY : Y ‚ü∂ Y') (mW : W ‚ü∂ W') (mZ : Z ‚ü∂ Z')
    (hbot : f' ‚â´ g' = h' ‚â´ i')
    (hf : f ‚â´ mY = mX ‚â´ f')
    (hh : h ‚â´ mW = mX ‚â´ h')
    (hg : g ‚â´ mZ = mY ‚â´ g')
    (hi : i ‚â´ mZ = mW ‚â´ i')
    [e : Mono mZ]
    : f ‚â´ g = h ‚â´ i := by
  apply e.right_cancellation
  calc (f ‚â´ g) ‚â´ mZ
    _ = f ‚â´ g ‚â´ mZ := by aesop
    _ = f ‚â´ mY ‚â´ g' := by aesop
    _ = (f ‚â´ mY) ‚â´ g' := by simp
    _  = (mX ‚â´ f') ‚â´ g' := by aesop
    _  = mX ‚â´ f' ‚â´ g' := by simp
    _  = mX ‚â´ h' ‚â´ i' := by aesop
    _  = (mX ‚â´ h') ‚â´ i' := by simp
    _  = (h ‚â´ mW) ‚â´ i' := by aesop
    _  = h ‚â´ mW ‚â´ i' := by simp
    _  = h ‚â´ i ‚â´ mZ := by aesop
    _  = (h ‚â´ i) ‚â´ mZ := by aesop

theorem pi_naturality_map {x y} (f : x ‚ü∂ y) :
    Grpd.homOf (piMap A B (œÉ.map f)) ‚â´ eqToHom (pi_naturality_obj A B œÉ y)
    = eqToHom (pi_naturality_obj A B œÉ x) ‚â´ (Grpd.homOf (piMap (œÉ ‚ãô A) (pre A œÉ ‚ãô B) f)) := by
  apply comm_sq_of_comp_mono (e := Grpd.Œπ_mono (Grpd.of (_ ‚•§ _))
      (IsSection (sigma.fstAuxObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) y)))
    (Grpd.homOf (piMap A B (œÉ.map f)))
    (eqToHom (pi_naturality_obj A B œÉ x))
    (eqToHom (pi_naturality_obj A B œÉ y)) (Grpd.homOf (piMap (œÉ ‚ãô A) (pre A œÉ ‚ãô B) f))
    (Grpd.homOf (conjugating A (sigma A B) (œÉ.map f)))
    (eqToHom (eqToHom_Œπ_aux A B œÉ x)) (eqToHom (eqToHom_Œπ_aux A B œÉ y))
    (Grpd.homOf (conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (pre A œÉ ‚ãô B)) f))
    (Grpd.homOf (ObjectProperty.Œπ _))
    (Grpd.homOf (ObjectProperty.Œπ _))
    (Grpd.homOf (ObjectProperty.Œπ _))
    (Grpd.homOf (ObjectProperty.Œπ _))
  ¬∑ rw [eqToHom_conjugating]
  ¬∑ rfl
  ¬∑ apply eqToHom_Œπ
  ¬∑ apply eqToHom_Œπ
  ¬∑ rfl

theorem pi_naturality : œÉ ‚ãô pi A B = pi (œÉ ‚ãô A) (pre A œÉ ‚ãô B) := by
  fapply CategoryTheory.Functor.ext
  ¬∑ apply pi_naturality_obj
  ¬∑ intro x y f
    erw [‚Üê Category.assoc, ‚Üê pi_naturality_map]
    simp [- Grpd.comp_eq_comp, - Grpd.id_eq_id]

end



namespace pi

variable {Œì : Type*} [Groupoid Œì] {A : Œì ‚•§ Grpd} (B : ‚à´(A) ‚•§ Grpd)
  (f : Œì ‚•§ PGrpd) (hf : f ‚ãô PGrpd.forgetToGrpd = pi A B)

-- NOTE: it seems like we need a 2-categorical version of Grothendieck.map
-- so the following should be replaced with something like
-- `secAux : CategoryTheory.Oplax.OplaxTrans A (sigma A B)`
def secAux : A ‚ü∂ sigma A B where
  app x := (PGrpd.objFiber' hf x).obj
  naturality x y g := by
    have h : (((pi A B).map g).obj (PGrpd.objFiber' hf x)).obj ‚ü∂ (PGrpd.objFiber' hf y).obj :=
      PGrpd.mapFiber' hf g
    simp [piMap_obj_obj] at h
    simp

    sorry

-- def secFib (x) : A.obj x ‚•§ ‚à´(sigma A B) := (PGrpd.objFiber' hf x).obj ‚ãô Œπ (sigma A B) x

-- def secHom {x y} (g : x ‚ü∂ y) : secFib B f hf x ‚ü∂ A.map g ‚ãô secFib B f hf y := by
--   have h : (((pi A B).map g).obj (PGrpd.objFiber' hf x)).obj ‚ü∂ (PGrpd.objFiber' hf y).obj :=
--       PGrpd.mapFiber' hf g
--   simp [piMap_obj_obj] at h
--   simp [secFib]
--   sorry

-- NOTE: this should be defined as something like `Grothendieck.Groupoidal.mapOplax secAux`
def sec : ‚à´(A) ‚•§ ‚à´(sigma A B) :=
  map sorry
  -- have h (x) := (PGrpd.objFiber' hf x).obj
  -- exact functorTo forget (fun x => (h x.base).obj x.fiber) sorry sorry sorry
  -- exact functorFrom (secFib B f hf) (fun {x y} g => sorry) sorry sorry

/--  Let `Œì` be a category.
For any pair of functors `A : Œì ‚•§ Grpd` and `B : ‚à´(A) ‚•§ Grpd`,
and any "term of pi", meaning a functor `f : Œì ‚•§ PGrpd`
satisfying `f ‚ãô forgetToGrpd = pi A B : Œì ‚•§ Grpd`,
there is a "term of `B`" `sec' : Œì ‚•§ PGrpd` such that `sec' ‚ãô forgetToGrpd = B`.
-/
def sec' : ‚à´(A) ‚•§ PGrpd := sorry ‚ãô sigma.assoc B ‚ãô toPGrpd B

def sec_forgetToGrpd : sec' B ‚ãô PGrpd.forgetToGrpd = B := sorry

end pi

section

variable {Œì : Type*} [Groupoid Œì] (A : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ}) (Œ≤ : ‚à´(A) ‚•§ PGrpd.{u‚ÇÅ,u‚ÇÅ})

section
variable (x : Œì)

def lamFibObjObj :=
  sec (Œπ A x ‚ãô Œ≤ ‚ãô PGrpd.forgetToGrpd) (Œπ A x ‚ãô Œ≤) rfl

@[simp] lemma lamFibObjObj_obj_base (a) : ((lamFibObjObj A Œ≤ x).obj a).base = a := by
  simp [lamFibObjObj]

@[simp] lemma lamFibObjObj_obj_fiber (a) : ((lamFibObjObj A Œ≤ x).obj a).fiber
    = PGrpd.objFiber (Œπ A x ‚ãô Œ≤) a := by
  simp [lamFibObjObj]

@[simp] lemma lamFibObjObj_map_base {a a'} (h: a ‚ü∂ a'):
    ((lamFibObjObj A Œ≤ x).map h).base = h := by
  simp [lamFibObjObj]

@[simp] lemma lamFibObjObj_map_fiber {a a'} (h: a ‚ü∂ a'):
    ((lamFibObjObj A Œ≤ x).map h).fiber = PGrpd.mapFiber (Œπ A x ‚ãô Œ≤) h := by
  simp [lamFibObjObj]

def lamFibObj : piObj (Œ≤ ‚ãô PGrpd.forgetToGrpd) x :=
  ‚ü®lamFibObjObj A Œ≤ x , rfl‚ü©

@[simp] lemma lamFibObj_obj : (lamFibObj A Œ≤ x).obj = lamFibObjObj A Œ≤ x :=
  rfl

@[simp] lemma lamFibObj_obj_obj : (lamFibObj A Œ≤ x).obj = lamFibObjObj A Œ≤ x :=
  rfl

end

section
variable {x y : Œì} (f : x ‚ü∂ y)

open CategoryTheory.Functor
def lamFibObjObjCompSigmaMap.app (a : A.obj x) :
    (lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f).obj a ‚ü∂
    (A.map f ‚ãô lamFibObjObj A Œ≤ y).obj a :=
  homMk (ùüô _) (eqToHom (by simp; rfl) ‚â´ (Œ≤.map ((ŒπNatTrans f).app a)).fiber)

@[simp] lemma lamFibObjObjCompSigmaMap.app_base (a : A.obj x) : (app A Œ≤ f a).base = ùüô _ := by
  simp [app]

lemma lamFibObjObjCompSigmaMap.app_fiber_eq (a : A.obj x) : (app A Œ≤ f a).fiber =
    eqToHom (by simp; rfl) ‚â´ (Œ≤.map ((ŒπNatTrans f).app a)).fiber := by
  simp [app]

lemma lamFibObjObjCompSigmaMap.app_fiber_heq (a : A.obj x) : (app A Œ≤ f a).fiber ‚âç
    (Œ≤.map ((ŒπNatTrans f).app a)).fiber := by
  simp [app]

lemma lamFibObjObjCompSigmaMap.naturality {x y : Œì} (f : x ‚ü∂ y) {a1 a2 : A.obj x} (h : a1 ‚ü∂ a2) :
    (lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f).map h
    ‚â´ lamFibObjObjCompSigmaMap.app A Œ≤ f a2 =
    lamFibObjObjCompSigmaMap.app A Œ≤ f a1
    ‚â´ (A.map f ‚ãô lamFibObjObj A Œ≤ y).map h := by
  apply Grothendieck.Groupoidal.hext
  ¬∑ simp
  ¬∑ have Œ≤_ŒπNatTrans_naturality : Œ≤.map ((Œπ A x).map h) ‚â´ Œ≤.map ((ŒπNatTrans f).app a2)
        = Œ≤.map ((ŒπNatTrans f).app a1) ‚â´ Œ≤.map ((A.map f ‚ãô Œπ A y).map h) := by
      simp [‚Üê Functor.map_comp, (ŒπNatTrans f).naturality h]
    have h_naturality : (Œ≤.map ((ŒπNatTrans f).app a2)).base.map (Œ≤.map ((Œπ A x).map h)).fiber
        ‚â´ (Œ≤.map ((ŒπNatTrans f).app a2)).fiber ‚âç
        (Œ≤.map ((Œπ A y).map ((A.map f).map h))).base.map (Œ≤.map ((ŒπNatTrans f).app a1)).fiber
        ‚â´ (Œ≤.map ((Œπ A y).map ((A.map f).map h))).fiber := by
      simpa [‚Üê heq_eq_eq] using Grothendieck.congr Œ≤_ŒπNatTrans_naturality
    simp only [Functor.comp_obj, sigmaMap_obj_base, Functor.comp_map, comp_base, sigmaMap_map_base,
      comp_fiber, sigmaMap_map_fiber, lamFibObjObj_map_fiber, Functor.map_comp, eqToHom_map,
      app_fiber_eq, Category.assoc, heq_eqToHom_comp_iff, eqToHom_comp_heq_iff]
    rw [‚Üê Category.assoc]
    apply HEq.trans _ h_naturality
    apply heq_comp _ rfl rfl _ HEq.rfl
    ¬∑ aesop_cat
    ¬∑ simp only [‚Üê Functor.comp_map, ‚Üê Grpd.comp_eq_comp, comp_eqToHom_heq_iff]
      congr 3
      aesop_cat

@[simp] lemma lamFibObjObjCompSigmaMap.app_id (a) : lamFibObjObjCompSigmaMap.app A Œ≤ (ùüô x) a
    = eqToHom (by simp) := by
  apply Grothendieck.Groupoidal.hext
  ¬∑ simp
  ¬∑ simp [app]
    rw! (castMode := .all) [ŒπNatTrans_id_app]
    simp only [Grothendieck.congr (eqToHom_map Œ≤ _), Grothendieck.fiber_eqToHom, eqToHom_trans]
    apply (eqToHom_heq_id_cod _ _ _).trans (eqToHom_heq_id_cod _ _ _).symm

lemma lamFibObjObjCompSigmaMap.app_comp {x y z : Œì} (f : x ‚ü∂ y) (g : y ‚ü∂ z) (a) :
    lamFibObjObjCompSigmaMap.app A Œ≤ (f ‚â´ g) a
    = eqToHom (by simp)
    ‚â´ (sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g).map (app A Œ≤ f a)
    ‚â´ app A Œ≤ g ((A.map f).obj a) ‚â´ eqToHom (by simp) := by
  fapply Grothendieck.Groupoidal.ext
  ¬∑ simp
  ¬∑ have h : (Œ≤.map ((ŒπNatTrans (f ‚â´ g)).app a)) = Œ≤.map ((ŒπNatTrans f).app a)
      ‚â´ Œ≤.map ((ŒπNatTrans g).app ((A.map f).obj a))
      ‚â´ eqToHom (by simp) := by
      simp [ŒπNatTrans_comp_app]
    simp only [Grpd.forgetToCat.eq_1, comp_obj, Grothendieck.forget_obj, sigmaObj,
      sigmaMap_obj_base, app, Functor.comp_map, Grothendieck.forget_map, sigmaMap_obj_fiber,
      Cat.of_Œ±, id_eq, comp_base, sigmaMap_map_base, homMk_base, homMk_fiber, Grothendieck.congr h,
      Grothendieck.comp_base, Grpd.comp_eq_comp, Grothendieck.comp_fiber, eqToHom_refl,
      Grothendieck.fiber_eqToHom, Category.id_comp, eqToHom_trans_assoc, comp_fiber, eqToHom_fiber,
      eqToHom_map, sigmaMap_map_fiber, map_comp, Category.assoc]
    rw! [Grothendieck.eqToHom_base, Category.id_comp, eqToHom_base, eqToHom_base, eqToHom_map,
      eqToHom_map, eqToHom_map, Grothendieck.eqToHom_base]
    aesop_cat

/-
a ---h---> a' in A.obj x

B(x,a) ----> B(y,Afa)
 |               |
 |               |
 v               v
B(x,a')----> B(y,Afa')
-/

def lamFibObjObjCompSigmaMap :
    lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f ‚ü∂
    A.map f ‚ãô lamFibObjObj A Œ≤ y where
  app := lamFibObjObjCompSigmaMap.app A Œ≤ f
  naturality _ _ h := lamFibObjObjCompSigmaMap.naturality A Œ≤ f h

@[simp] lemma lamFibObjObjCompSigmaMap_id (x : Œì) : lamFibObjObjCompSigmaMap A Œ≤ (ùüô x) =
    eqToHom (by simp [sigmaMap_id]) := by
  ext a
  simp [lamFibObjObjCompSigmaMap]

/-
lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) (f ‚â´ g)

_ ‚ü∂ lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g
:= eqToHom ‚ãØ

_ ‚ü∂ A.map f ‚ãô lamFibObjObj A Œ≤ y ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g
:= whiskerRight (lamFibObjObjCompSigmaMap A Œ≤ f) (sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g)

_ ‚ü∂ A.map f ‚ãô A.map g ‚ãô lamFibObjObj A Œ≤ z
:= whiskerLeft (A.map f) (lamFibObjObjCompSigmaMap A Œ≤ g)

_ ‚ü∂ A.map (f ‚â´ g) ‚ãô lamFibObjObj A Œ≤ z
:= eqToHom ‚ãØ

-/

lemma lamFibObjObjCompSigmaMap_comp {x y z : Œì} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    lamFibObjObjCompSigmaMap A Œ≤ (f ‚â´ g) =
    eqToHom (by rw [sigmaMap_comp]; rfl)
    ‚â´ whiskerRight (lamFibObjObjCompSigmaMap A Œ≤ f) (sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g)
    ‚â´ whiskerLeft (A.map f) (lamFibObjObjCompSigmaMap A Œ≤ g)
    ‚â´ eqToHom (by rw [Functor.map_comp, Grpd.comp_eq_comp, Functor.assoc]) := by
  ext a
  simp [lamFibObjObjCompSigmaMap, lamFibObjObjCompSigmaMap.app_comp]

def whiskerLeftInvLamObjObjSigmaMap :
    A.map (CategoryTheory.inv f) ‚ãô lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f ‚ü∂
    lamFibObjObj A Œ≤ y :=
  whiskerLeft (A.map (CategoryTheory.inv f)) (lamFibObjObjCompSigmaMap A Œ≤ f)
  ‚â´ eqToHom (by simp [‚Üê Functor.assoc, ‚Üê Grpd.comp_eq_comp])

@[simp] lemma whiskerLeftInvLamObjObjSigmaMap_id (x : Œì) :
    whiskerLeftInvLamObjObjSigmaMap A Œ≤ (ùüô x) = eqToHom (by simp [sigmaMap_id]) := by
  simp [whiskerLeftInvLamObjObjSigmaMap]

-- TODO find a better proof. This should not need `ext`,
-- instead should be by manipulating whiskerLeft and whiskerRight lemmas
lemma whiskerLeftInvLamObjObjSigmaMap_comp {x y z} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    whiskerLeftInvLamObjObjSigmaMap A Œ≤ (f ‚â´ g)
    = eqToHom (by simp [Functor.assoc, sigmaMap_comp])
    ‚â´ whiskerRight (whiskerLeft (A.map (CategoryTheory.inv g)) (whiskerLeftInvLamObjObjSigmaMap A Œ≤ f))
      (sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g)
    ‚â´ whiskerLeftInvLamObjObjSigmaMap A Œ≤ g := by
  simp only [whiskerLeftInvLamObjObjSigmaMap, lamFibObjObjCompSigmaMap_comp]
  rw! [Functor.map_inv, Functor.map_inv, Functor.map_inv,
    Functor.map_comp, IsIso.inv_comp]
  ext
  simp only [Grpd.forgetToCat.eq_1, sigmaObj, Grpd.comp_eq_comp, comp_obj, eqToHom_refl,
    Category.comp_id, whiskerLeft_comp, whiskerLeft_eqToHom, whiskerLeft_twice, Category.assoc,
    NatTrans.comp_app, eqToHom_app, whiskerLeft_app, whiskerRight_app, associator_inv_app,
    associator_hom_app, Category.id_comp, whiskerRight_comp, eqToHom_whiskerRight, map_id]
  congr 2
  simp only [‚Üê comp_obj, Functor.assoc]
  simp only [‚Üê Grpd.comp_eq_comp]
  rw! (castMode := .all) [IsIso.inv_hom_id]
  apply eq_of_heq
  simp [- heq_eq_eq]
  rfl

def lamFibMap :
    ((pi A (Œ≤ ‚ãô PGrpd.forgetToGrpd)).map f).obj (lamFibObj A Œ≤ x) ‚ü∂ lamFibObj A Œ≤ y :=
  whiskerLeftInvLamObjObjSigmaMap A Œ≤ f

@[simp] lemma lamFibMap_id (x : Œì) : lamFibMap A Œ≤ (ùüô x) = eqToHom (by simp) := by
  simp [lamFibMap]
  rfl

lemma lamFibMap_comp {x y z} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    lamFibMap A Œ≤ (f ‚â´ g)
    = eqToHom (by rw [‚Üê Functor.comp_obj]; apply Functor.congr_obj; simp [piMap_comp])
    ‚â´ ((piMap A (Œ≤ ‚ãô PGrpd.forgetToGrpd)) g).map ((lamFibMap A Œ≤) f)
    ‚â´ lamFibMap A Œ≤ g := by
  simp [lamFibMap, piMap, whiskerLeftInvLamObjObjSigmaMap_comp]
  rfl

def lam : Œì ‚•§ PGrpd.{u‚ÇÅ,u‚ÇÅ} :=
  PGrpd.functorTo
  (pi A (Œ≤ ‚ãô PGrpd.forgetToGrpd))
  (lamFibObj A Œ≤)
  (lamFibMap A Œ≤)
  (lamFibMap_id A Œ≤)
  (lamFibMap_comp A Œ≤)

lemma lam_comp_forgetToGrpd : lam A Œ≤ ‚ãô PGrpd.forgetToGrpd = pi A (Œ≤ ‚ãô PGrpd.forgetToGrpd) :=
  rfl

--I add here

variable {Œî : Type u‚ÇÅ} [Groupoid.{v‚ÇÅ} Œî] (œÉ : Œî ‚•§ Œì)
#check lam (œÉ ‚ãô A) (pre A œÉ ‚ãô Œ≤)
theorem lam_naturality : œÉ ‚ãô lam A Œ≤ = lam (œÉ ‚ãô A) (pre A œÉ ‚ãô Œ≤)
     := by
  apply PGrpd.Functor.hext
  ¬∑ apply pi_naturality
  ¬∑ intro x
    --apply pair_naturality_obj
    sorry
  ¬∑ intro x y f
    sorry
    -- apply hext'
    -- ¬∑ rw [‚Üê Functor.assoc, pair_naturality_Œπ_pre]
    -- ¬∑ apply pair_naturality_aux_1
    -- ¬∑ apply pair_naturality_obj
    -- ¬∑ simp [- Functor.comp_obj, - Functor.comp_map, Functor.comp_map, mapFiber_naturality]
    -- ¬∑ simp [- Functor.comp_obj, - Functor.comp_map, Functor.comp_map, ‚Üê mapFiber'_naturality]


--add end here
end
end

section
variable {Œì : Ctx}

namespace smallUPi

def Pi_app (AB : y(Œì) ‚ü∂ smallU.{v}.Ptp.obj smallU.{v}.Ty) :
    y(Œì) ‚ü∂ smallU.{v}.Ty :=
  yonedaCategoryEquiv.symm (pi _ (smallU.PtpEquiv.snd AB))

def Pi_naturality {Œî Œì} (f : Œî ‚ü∂ Œì) (Œ± : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Ty) :
    Pi_app (ym(f) ‚â´ Œ±) = ym(f) ‚â´ Pi_app Œ± := by
     dsimp only [Pi_app]
     rw [‚Üê yonedaCategoryEquiv_symm_naturality_left, pi_naturality,
     smallU.PtpEquiv.snd_naturality]
     rw! [smallU.PtpEquiv.fst_naturality]
     congr 2
     ¬∑ simp [map_id_eq, Functor.id_comp]


/-- The formation rule for Œ†-types for the natural model `smallU` -/
def Pi : smallU.{v}.Ptp.obj smallU.{v}.Ty ‚ü∂ smallU.{v}.Ty :=
  NatTrans.yonedaMk Pi_app Pi_naturality

lemma Pi_app_eq {Œì : Ctx} (ab : y(Œì) ‚ü∂ _) : ab ‚â´ Pi =
    yonedaCategoryEquiv.symm (FunctorOperation.pi _ (smallU.PtpEquiv.snd ab)) := by
  rw [Pi, NatTrans.yonedaMk_app, Pi_app]

def lam_app (ab : y(Œì) ‚ü∂ smallU.{v}.Ptp.obj smallU.{v}.Tm) :
    y(Œì) ‚ü∂ smallU.{v}.Tm :=
  yonedaCategoryEquiv.symm (lam _ (smallU.PtpEquiv.snd ab))

def lam_naturality {Œî Œì} (f : Œî ‚ü∂ Œì) (Œ± : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Tm) :
    lam_app (ym(f) ‚â´ Œ±) = ym(f) ‚â´ lam_app Œ± := by
    dsimp only [lam_app]
  -- rw [‚Üê yonedaCategoryEquiv_symm_naturality_left, FunctorOperation.pair_naturality]
  -- -- Like with `smallUSigma.Sig_naturality` rw from inside to outside (w.r.t type dependency)
  -- rw! [dependent_naturality, snd_naturality, fst_naturality]
  -- simp [map_id_eq, Functor.id_comp]




    sorry

/-- The introduction rule for Œ†-types for the natural model `smallU` -/
def lam : smallU.{v}.Ptp.obj smallU.{v}.Tm ‚ü∂ smallU.{v}.Tm :=
  NatTrans.yonedaMk lam_app lam_naturality

lemma lam_app_eq {Œì : Ctx} (ab : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Tm) : ab ‚â´ lam =
    yonedaCategoryEquiv.symm (FunctorOperation.lam _ (smallU.PtpEquiv.snd ab)) := by
  rw [lam, NatTrans.yonedaMk_app, lam_app]

lemma smallU.PtpEquiv.fst_app_comp_map_tp {Œì : Ctx} (ab : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Tm) :
    smallU.PtpEquiv.fst (ab ‚â´ smallU.Ptp.map smallU.tp) = smallU.PtpEquiv.fst ab :=
  sorry

lemma smallU.PtpEquiv.snd_app_comp_map_tp {Œì : Ctx} (ab : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Tm) :
    smallU.PtpEquiv.snd (ab ‚â´ smallU.Ptp.map smallU.tp)
    ‚âç smallU.PtpEquiv.snd ab ‚ãô PGrpd.forgetToGrpd :=
  sorry

theorem lam_tp : smallUPi.lam ‚â´ smallU.tp = smallU.Ptp.map smallU.tp ‚â´ Pi := by
  apply hom_ext_yoneda
  intros Œì ab
  rw [‚Üê Category.assoc, ‚Üê Category.assoc, lam_app_eq, Pi_app_eq, smallU_tp, œÄ,
    ‚Üê yonedaCategoryEquiv_symm_naturality_right, lam_comp_forgetToGrpd]
  symm; congr 2
  ¬∑ apply smallU.PtpEquiv.fst_app_comp_map_tp
  ¬∑ apply smallU.PtpEquiv.snd_app_comp_map_tp

section
variable {Œì : Ctx} (AB : y(Œì) ‚ü∂ smallU.Ptp.obj.{v} y(U.{v}))
  (Œ±Œ≤ : y(Œì) ‚ü∂ y(E.{v})) (hŒ±Œ≤ : Œ±Œ≤ ‚â´ ym(œÄ) = AB ‚â´ smallUPi.Pi)

include hŒ±Œ≤ in
theorem yonedaCategoryEquiv_forgetToGrpd : yonedaCategoryEquiv Œ±Œ≤ ‚ãô PGrpd.forgetToGrpd
    = pi (smallU.PtpEquiv.fst AB) (smallU.PtpEquiv.snd AB) := by
  erw [‚Üê yonedaCategoryEquiv_naturality_right, hŒ±Œ≤]
  rw [smallUPi.Pi_app_eq, yonedaCategoryEquiv.apply_symm_apply]

def lift : y(Œì) ‚ü∂ smallU.Ptp.obj.{v} smallU.Tm.{v} :=
  let Œ±Œ≤' := yonedaCategoryEquiv Œ±Œ≤
  smallU.PtpEquiv.mk (smallU.PtpEquiv.fst AB) sorry

  -- let Œ≤' := smallU.PtpEquiv.snd AB
  -- let Œ±Œ≤' := yonedaCategoryEquiv Œ±Œ≤
  -- let hŒ±Œ≤' : yonedaCategoryEquiv Œ±Œ≤ ‚ãô forgetToGrpd
  --   = sigma (smallU.PtpEquiv.fst AB) (smallU.PtpEquiv.snd AB) :=
  --   yonedaCategoryEquiv_forgetToGrpd _ _ hŒ±Œ≤
  -- mk (sigma.fst' Œ≤' Œ±Œ≤' hŒ±Œ≤') (sigma.dependent' Œ≤' Œ±Œ≤' hŒ±Œ≤')
  -- (sigma.snd' Œ≤' Œ±Œ≤' hŒ±Œ≤') (sigma.snd'_forgetToGrpd Œ≤' Œ±Œ≤' hŒ±Œ≤')

-- theorem fac_left : lift.{v} AB Œ±Œ≤ hŒ±Œ≤ ‚â´ smallUSigma.pair.{v} = Œ±Œ≤ := by
--   rw [smallUSigma.pair_app_eq]
--   dsimp only [lift]
--   rw! [dependent_mk, snd_mk, fst_mk]
--   simp only [eqToHom_refl, map_id_eq, Cat.of_Œ±, Functor.id_comp]
--   rw [yonedaCategoryEquiv.symm_apply_eq, sigma.eta]

-- theorem fac_right : lift.{v} AB Œ±Œ≤ hŒ±Œ≤ ‚â´ smallU.comp.{v} = AB := by
--   apply smallU.PtpEquiv.hext
--   ¬∑ rw [‚Üê fst_forgetToGrpd]
--     dsimp only [lift]
--     rw [fst_mk, sigma.fst'_forgetToGrpd]
--   ¬∑ apply HEq.trans (dependent_heq _).symm
--     rw [lift, dependent_mk]
--     dsimp [sigma.dependent']
--     simp [map_id_eq, Functor.id_comp]
--     apply map_eqToHom_comp_heq

-- theorem hom_ext (m n : y(Œì) ‚ü∂ smallU.compDom.{v})
--     (hComp : m ‚â´ smallU.comp = n ‚â´ smallU.comp)
--     (hPair : m ‚â´ smallUSigma.pair = n ‚â´ smallUSigma.pair) : m = n := by
--   have h : (pair (fst m) (snd m) (dependent m)
--         (snd_forgetToGrpd m)) =
--       (pair (fst n) (snd n) (dependent n)
--         (snd_forgetToGrpd n)) :=
--       calc _
--         _ = yonedaCategoryEquiv (m ‚â´ smallUSigma.pair) := by
--           simp [smallUSigma.pair_app_eq m]
--         _ = yonedaCategoryEquiv (n ‚â´ smallUSigma.pair) := by rw [hPair]
--         _ = _ := by
--           simp [smallUSigma.pair_app_eq n]
--   have hdep : HEq (dependent m) (dependent n) := by
--     refine (dependent_heq _).trans
--       $ HEq.trans ?_ $ (dependent_heq _).symm
--     rw [hComp]
--   have : fst m ‚ãô forgetToGrpd = fst n ‚ãô forgetToGrpd := by
--     rw [fst_forgetToGrpd, fst_forgetToGrpd, hComp]
--   apply smallU.compDom.hext
--   ¬∑ calc fst m
--       _ = sigma.fst' _ (FunctorOperation.pair (fst m) (snd m)
--         (dependent m) (snd_forgetToGrpd m)) _ :=
--           (sigma.fst'_pair _).symm
--       _ = sigma.fst' _ (FunctorOperation.pair (fst n) (snd n)
--         (dependent n) (snd_forgetToGrpd n)) _ := by
--           rw! [h]
--           congr!
--       _ = fst n := sigma.fst'_pair _
--   ¬∑ exact hdep
--   ¬∑ calc snd m
--       _ = sigma.snd' _ (FunctorOperation.pair (fst m) (snd m)
--         (dependent m) (snd_forgetToGrpd m)) _ :=
--           (sigma.snd'_pair _).symm
--       _ = sigma.snd' _ (FunctorOperation.pair (fst n) (snd n)
--         (dependent n) (snd_forgetToGrpd n)) _ := by
--           rw! [h]
--           congr!
--       _ = snd n := sigma.snd'_pair _

-- theorem uniq (m : y(Œì) ‚ü∂ smallU.compDom)
--     (hmAB : m ‚â´ smallU.comp = AB) (hmŒ±Œ≤ : m ‚â´ smallUSigma.pair = Œ±Œ≤) :
--     m = lift AB Œ±Œ≤ hŒ±Œ≤ := by
--   apply hom_ext
--   ¬∑ rw [hmAB, fac_right]
--   ¬∑ rw [hmŒ±Œ≤, fac_left]

end
theorem isPullback : IsPullback lam.{v,u} (smallU.Ptp.{v,u}.map smallU.tp)
    smallU.{v, u}.tp Pi.{v, u} :=
  Limits.RepPullbackCone.is_pullback lam_tp
    (fun s => sorry)
    (fun s => sorry)
    (fun s => sorry)
    (fun s m fac_left fac_right => sorry)
  -- Limits.RepPullbackCone.is_pullback smallUSigma.lam_tp.{v,u}
  --   (fun s => lift s.snd s.fst s.condition)
  --   (fun s => fac_left.{v,u} _ _ s.condition)
  --   (fun s => fac_right.{v,u} _ _ s.condition)
  --   (fun s m fac_left fac_right => uniq.{v,u} _ _ s.condition m fac_right fac_left)

end smallUPi

def smallUPi : NaturalModelPi smallU.{v} where
  Pi := smallUPi.Pi.{v}
  lam := smallUPi.lam.{v}
  Pi_pullback := sorry

def uHomSeqPis' (i : ‚Ñï) (ilen : i < 4) :
  NaturalModelPi (uHomSeqObjs i ilen) :=
  match i with
  | 0 => smallUPi.{0,4}
  | 1 => smallUPi.{1,4}
  | 2 => smallUPi.{2,4}
  | 3 => smallUPi.{3,4}
  | (n+4) => by omega

def uHomSeqPis : UHomSeqPiSigma Ctx := { uHomSeq with
  nmPi := uHomSeqPis'
  nmSigma := uHomSeqSigmas' }

end

end FunctorOperation

end GroupoidModel
