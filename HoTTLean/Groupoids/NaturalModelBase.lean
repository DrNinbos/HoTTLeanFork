import Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory
import Mathlib.CategoryTheory.Category.Cat.Limit

import HoTTLean.Model.UHom
import HoTTLean.Grothendieck.Groupoidal.IsPullback
import HoTTLean.Groupoids.IsPullback
import HoTTLean.ForMathlib.CategoryTheory.IsIsofibration

/-!
Here we construct universes for the groupoid natural model.
-/

universe w v u v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ v‚ÇÉ u‚ÇÉ

noncomputable section
open CategoryTheory Limits NaturalModel Universe
  Functor.Groupoidal GroupoidModel.Ctx GroupoidModel.U

namespace GroupoidModel

open U

/-- The universe the classifies `v`-large terms and types.
  The œÄ-clan we use is the set of groupoid isofibrations.
-/
@[simps]
def U : Universe Grpd.IsIsofibration where
  Ty := Ty.{v}
  Tm := Tm.{v}
  tp := tp
  morphismProperty := sorry
  ext A := ext A
  disp A := disp A
  var A := var A
  disp_pullback A := GroupoidModel.IsPullback.disp_pullback A

namespace U

open MonoidalCategory

def asSmallClosedType : (tensorUnit _ : Ctx) ‚ü∂ Ty.{v+1, max u (v+2)} :=
  toCoreAsSmallEquiv.symm ((Functor.const _).obj
    (Grpd.of (Core (AsSmall.{v+1} Grpd.{v,v}))))

def isoExtAsSmallClosedTypeHom :
    Core (AsSmall.{max u (v+2)} Grpd.{v,v})
    ‚•§ ‚à´(toCoreAsSmallEquiv (asSmallClosedType.{v, max u (v + 2)})) where
  obj X := objMk ‚ü®‚ü®‚ü©‚ü© ‚ü®AsSmall.up.obj.{_,_,v+1} (AsSmall.down.obj X.of)‚ü©
  map {X Y} F := homMk (ùüô _) ‚ü®{
    hom := AsSmall.up.map.{_,_,v+1} (AsSmall.down.map F.iso.hom)
    inv := AsSmall.up.map.{_,_,v+1} (AsSmall.down.map (F.iso.inv))
    hom_inv_id := by
      simp only [‚Üê Functor.map_comp, Iso.hom_inv_id]
      rfl
    inv_hom_id := by
      simp only [‚Üê Functor.map_comp, Iso.inv_hom_id]
      rfl }‚ü©

def isoExtAsSmallClosedTypeInv :
    ‚à´(toCoreAsSmallEquiv (asSmallClosedType.{v, max u (v + 2)})) ‚•§
    Core (AsSmall.{max u (v+2)} Grpd.{v,v}) where
  obj X := ‚ü®AsSmall.up.obj (AsSmall.down.obj.{_,_,v+1} X.fiber.of)‚ü©
  map {X Y} F := ‚ü®{
    hom := AsSmall.up.map.{_,_,max u (v+2)}
      (AsSmall.down.map F.fiber.iso.hom)
    inv := AsSmall.up.map.{_,_,max u (v+2)}
      (AsSmall.down.map F.fiber.iso.inv)
    hom_inv_id := by
      simp only [‚Üê Functor.map_comp, Iso.hom_inv_id]
      rfl
    inv_hom_id := by
      simp only [‚Üê Functor.map_comp, Iso.inv_hom_id]
      rfl }‚ü©

def isoExtAsSmallClosedType :
    Ty.{v,max u (v+2)}
    ‚âÖ U.{v+1,max u (v+2)}.ext U.asSmallClosedType.{v, max u (v+2)} where
  hom := (Grpd.homOf isoExtAsSmallClosedTypeHom.{v,u})
  inv := (Grpd.homOf isoExtAsSmallClosedTypeInv.{v,u})
  hom_inv_id := rfl
  inv_hom_id := rfl

end U

def liftSeqObjs (i : Nat) (h : i < 4) : Universe Grpd.IsIsofibration.{4} :=
  match i with
  | 0 => U.{0,4}
  | 1 => U.{1,4}
  | 2 => U.{2,4}
  | 3 => U.{3,4}
  | (n+4) => by omega

-- TODO: rename UHom to Universe.Lift
def lift : UHom U.{v, max u (v+2)} U.{v+1, max u (v+2)} :=
    @UHom.ofTyIsoExt _ _ _ _ _ _
    { mapTy := U.liftTy.{v,max u (v+2)}
      mapTm := U.liftTm
      pb := IsPullback.liftTm_isPullback }
    asSmallClosedType
    isoExtAsSmallClosedType.{v,u}

def liftSeqHomSucc' (i : Nat) (h : i < 3) :
    UHom (liftSeqObjs i (by omega)) (liftSeqObjs (i + 1) (by omega)) :=
  match i with
  | 0 => lift.{0,4}
  | 1 => lift.{1,4}
  | 2 => lift.{2,4}
  | (n+3) => by omega

/--
  The groupoid natural model with three nested representable universes
  within the ambient natural model.
-/
def liftSeq : UHomSeq Grpd.IsIsofibration.{4} where
  length := 3
  objs := liftSeqObjs
  homSucc' := liftSeqHomSucc'

open CategoryTheory Opposite

section

variable {Œì : Grpd} {C : Type (v+1)} [Category.{v} C] {Œî : Grpd} (œÉ : Œî ‚ü∂ Œì)

namespace U

theorem substWk_eq (A : Œì ‚ü∂ U.Ty.{v}) (œÉA : Œî ‚ü∂ U.Ty.{v}) (eq) :
    U.substWk œÉ A œÉA eq =
    map (eqToHom (by subst eq; rfl)) ‚ãô pre (toCoreAsSmallEquiv A) œÉ := by
  apply (U.disp_pullback A).hom_ext
  ¬∑ rw [substWk_var]
    simp [var, Grpd.comp_eq_comp]
    rw [‚Üê toCoreAsSmallEquiv_symm_apply_comp_left, Functor.assoc, pre_toPGrpd,
      map_eqToHom_toPGrpd]
  ¬∑ rw [substWk_disp]
    simp [Grpd.comp_eq_comp, Functor.assoc]
    erw [pre_comp_forget, ‚Üê Functor.assoc, map_forget]

@[simp] theorem sec_eq {Œì : Ctx} (Œ± : Œì ‚ü∂ U.{v}.Tm) (A : Œì ‚ü∂ U.{v}.Ty) (hŒ± : Œ± ‚â´ U.tp = A) :
    U.sec _ Œ± hŒ± = sec (toCoreAsSmallEquiv A) (toCoreAsSmallEquiv Œ±)
    (by rw [‚Üê hŒ±, Grpd.comp_eq_comp, tp, toCoreAsSmallEquiv_apply_comp_right]) := by
  apply (U.disp_pullback _).hom_ext
  . erw [Universe.sec_var, U_var, var, Grpd.comp_eq_comp,
      ‚Üê toCoreAsSmallEquiv_symm_apply_comp_left, Equiv.eq_symm_apply, sec_toPGrpd]
    rfl
  . rw [sec_disp]
    rfl

namespace PtpEquiv

variable (AB : Œì ‚ü∂ U.{v}.Ptp.obj (Ctx.coreAsSmall C))

/--
A map `(AB : (Œì) ‚ü∂ U.{v}.Ptp.obj (Ctx.ofCategory C))`
is equivalent to a pair of functors `A : Œì ‚•§ Grpd` and `B : ‚à´(fst AB) ‚•§ C`,
thought of as a dependent pair `A : Type` and `B : A ‚ü∂ Type` when `C = Grpd`.
`PtpEquiv.fst` is the `A` in this pair.
-/
def fst : Œì ‚•§ Grpd.{v,v} :=
  toCoreAsSmallEquiv (Universe.PtpEquiv.fst U AB)

variable (A := fst AB) (hA : A = fst AB := by rfl)

/--
A map `(AB : (Œì) ‚ü∂ U.{v}.Ptp.obj (Ctx.ofCategory C))`
is equivalent to a pair of functors `A : Œì ‚•§ Grpd` and `B : ‚à´(fst AB) ‚•§ C`,
thought of as a dependent pair `A : Type` and `B : A ‚ü∂ Type` when `C = Grpd`.
`PtpEquiv.snd` is the `B` in this pair.
-/
def snd : ‚à´A ‚•§ C :=
  toCoreAsSmallEquiv (Universe.PtpEquiv.snd U AB (toCoreAsSmallEquiv.symm A) (by
    simp [Universe.PtpEquiv.fst, hA, fst]))

nonrec theorem fst_comp_left : fst (œÉ ‚â´ AB) = œÉ ‚ãô fst AB := by
  dsimp only [fst]
  rw [PtpEquiv.fst_comp_left, ‚Üê toCoreAsSmallEquiv_apply_comp_left, Grpd.comp_eq_comp]

theorem fst_comp_right {D : Type (v + 1)} [Category.{v, v + 1} D] (F : C ‚•§ D) :
    fst (AB ‚â´ U.Ptp.map (Ctx.coreAsSmallFunctor F)) = fst AB := by
  dsimp only [fst]
  rw [Universe.PtpEquiv.fst_comp_right]

nonrec theorem snd_comp_left : snd (œÉ ‚â´ AB) (œÉ ‚ãô A) (by rw [hA, fst_comp_left]) =
    map (eqToHom (by rw [hA])) ‚ãô pre _ œÉ ‚ãô snd AB := by
  dsimp only [snd]
  erw [PtpEquiv.snd_comp_left _ rfl
    (by simp [toCoreAsSmallEquiv_symm_apply_comp_left, Grpd.comp_eq_comp, hA, fst]),
    toCoreAsSmallEquiv_apply_comp_left]
  subst hA
  simp [map_id_eq, substWk_eq]; rfl

/--
A map `(AB : (Œì) ‚ü∂ U.{v}.Ptp.obj (Ctx.ofCategory C))`
is equivalent to a pair of functors `A : Œì ‚•§ Grpd` and `B : ‚à´(fst AB) ‚•§ C`,
thought of as a dependent pair `A : Type` and `B : A ‚ü∂ Type` when `C = Grpd`.
`PtpEquiv.mk` constructs such a map `AB` from such a pair `A` and `B`.
-/
def mk (A : Œì ‚•§ Grpd.{v,v}) (B : ‚à´(A) ‚•§ C) :
    Œì ‚ü∂ U.{v}.Ptp.obj (Ctx.coreAsSmall C) :=
  Universe.PtpEquiv.mk U (toCoreAsSmallEquiv.symm A) (toCoreAsSmallEquiv.symm B)

theorem hext (AB1 AB2 : Œì ‚ü∂ U.{v}.Ptp.obj Ty.{v}) (hfst : fst AB1 = fst AB2)
    (hsnd : HEq (snd AB1) (snd AB2)) : AB1 = AB2 := by
  have hfst' : Universe.PtpEquiv.fst U AB1 = Universe.PtpEquiv.fst U AB2 := by
    dsimp [fst] at hfst
    aesop
  apply Universe.PtpEquiv.ext U (Universe.PtpEquiv.fst U AB1) ?_ hfst' ?_
  ¬∑ simp
  ¬∑ dsimp only [snd] at hsnd
    apply toCoreAsSmallEquiv.injective
    conv => right; rw! (castMode := .all) [hfst']
    simp [‚Üê heq_eq_eq]
    exact hsnd

@[simp]
lemma fst_mk (A : Œì ‚•§ Grpd.{v,v}) (B : ‚à´(A) ‚•§ C) :
    fst (mk A B) = A := by
  simp [fst, mk, Universe.PtpEquiv.fst_mk]

lemma Grpd.eqToHom_comp_heq {A B : Grpd} {C : Type*} [Category C]
    (h : A = B) (F : B ‚•§ C) : eqToHom h ‚ãô F ‚âç F := by
  subst h
  simp [Grpd.id_eq_id, Functor.id_comp]

lemma snd_mk (A A' : Œì ‚•§ Grpd.{v,v}) (hA : A = A') (B : ‚à´(A) ‚•§ C) :
    snd (mk A B) A' (by rw [fst_mk, hA]) = map (eqToHom hA.symm) ‚ãô B := by
  dsimp only [snd, mk]
  subst hA
  rw [Universe.PtpEquiv.snd_mk U (toCoreAsSmallEquiv.symm A) (toCoreAsSmallEquiv.symm B)]
  erw [Equiv.apply_symm_apply toCoreAsSmallEquiv B]
  simp [map_id_eq]

lemma snd_mk_heq (A : Œì ‚•§ Grpd.{v,v}) (B : ‚à´(A) ‚•§ C) :
    snd (mk A B) ‚âç B := by
  simp [snd_mk, map_eqToHom_comp_heq]

end PtpEquiv

def compDom := U.{v}.uvPolyTp.compDom U.{v}.uvPolyTp

@[simp]
abbrev compP : compDom.{v} ‚ü∂ U.{v}.Ptp.obj Ty.{v} :=
  Universe.compP U U

namespace compDom

variable (ab : (Œì) ‚ü∂ compDom.{v})

/-- Universal property of `compDom`, decomposition (part 1).

A map `ab : (Œì) ‚ü∂ compDom` is equivalently three functors
`fst, dependent, snd` such that `snd_forgetToGrpd`. The functor `fst : Œì ‚•§ PGrpd`
is `(a : A)` in `(a : A) √ó (b : B a)`.
-/
def fst : Œì ‚•§ PGrpd.{v,v} :=
  toCoreAsSmallEquiv (Universe.compDomEquiv.fst ab)

/-- Universal property of `compDom`, decomposition (part 2).

A map `ab : (Œì) ‚ü∂ compDom` is equivalently three functors
`fst, dependent, snd` such that `snd_forgetToGrpd`. The functor `dependent : Œì ‚•§ Grpd`
is `B : A ‚Üí Type` in `(a : A) √ó (b : B a)`.
-/
def dependent (A := fst ab ‚ãô PGrpd.forgetToGrpd) (eq : fst ab ‚ãô PGrpd.forgetToGrpd = A := by rfl) :
    ‚à´(A) ‚•§ Grpd.{v,v} :=
  toCoreAsSmallEquiv (Universe.compDomEquiv.dependent ab (toCoreAsSmallEquiv.symm A) (by
    simp only [U_Ty, U_Tm, compDomEquiv.fst, U_tp, ‚Üê eq]
    erw [toCoreAsSmallEquiv_symm_apply_comp_right]
    simp [fst]; rfl))

/-- Universal property of `compDom`, decomposition (part 3).

A map `ab : (Œì) ‚ü∂ compDom` is equivalently three functors
`fst, dependent, snd` such that `snd_forgetToGrpd`. The functor `snd : Œì ‚•§ PGrpd`
is `(b : B a)` in `(a : A) √ó (b : B a)`.
-/
def snd : Œì ‚•§ PGrpd.{v,v} :=
  toCoreAsSmallEquiv (Universe.compDomEquiv.snd ab)

/-- Universal property of `compDom`, decomposition (part 4).

A map `ab : (Œì) ‚ü∂ compDom` is equivalently three functors
`fst, dependent, snd` such that `snd_forgetToGrpd`.
The equation `snd_forgetToGrpd` says that the type of `b : B a` agrees with
the expression for `B a` obtained solely from `dependent`, or `B : A ‚ü∂ Type`.
-/
theorem snd_forgetToGrpd : snd ab ‚ãô PGrpd.forgetToGrpd = sec _ (fst ab) rfl ‚ãô (dependent ab) := by
  erw [‚Üê toCoreAsSmallEquiv_apply_comp_right, ‚Üê Grpd.comp_eq_comp,
    Universe.compDomEquiv.snd_tp ab, sec_eq]
  rfl

/-- Universal property of `compDom`, constructing a map into `compDom`. -/
def mk (Œ± : Œì ‚•§ PGrpd.{v,v}) (A := Œ± ‚ãô PGrpd.forgetToGrpd)
    (hA : Œ± ‚ãô PGrpd.forgetToGrpd = A := by rfl)
    (B : ‚à´(A) ‚•§ Grpd.{v,v})
    (Œ≤ : Œì ‚•§ PGrpd.{v,v}) (h : Œ≤ ‚ãô PGrpd.forgetToGrpd = sec _ Œ± hA ‚ãô B) :
    Œì ‚ü∂ compDom.{v} :=
  Universe.compDomEquiv.mk (toCoreAsSmallEquiv.symm Œ±) (A := toCoreAsSmallEquiv.symm A)
    (by rw [‚Üê hA, toCoreAsSmallEquiv_symm_apply_comp_right]; rfl)
    (toCoreAsSmallEquiv.symm B) (toCoreAsSmallEquiv.symm Œ≤)
    (by
      dsimp [U_tp, tp, Grpd.comp_eq_comp]
      rw [‚Üê toCoreAsSmallEquiv_symm_apply_comp_right Œ≤ PGrpd.forgetToGrpd, h,
        toCoreAsSmallEquiv_symm_apply_comp_left]
      congr 1
      simp only [sec_eq, Equiv.apply_symm_apply]
      rw! (castMode := .all) [toCoreAsSmallEquiv.apply_symm_apply]
      )

theorem fst_forgetToGrpd : fst ab ‚ãô PGrpd.forgetToGrpd =
    U.PtpEquiv.fst (ab ‚â´ compP.{v}) := by
  erw [U.PtpEquiv.fst, ‚Üê compDomEquiv.fst_tp ab, ‚Üê toCoreAsSmallEquiv_apply_comp_right]
  rfl

theorem dependent_eq (A := fst ab ‚ãô PGrpd.forgetToGrpd)
    (eq : fst ab ‚ãô PGrpd.forgetToGrpd = A := by rfl) : dependent ab A eq =
    map (eqToHom (by rw [‚Üê eq, fst_forgetToGrpd])) ‚ãô U.PtpEquiv.snd (ab ‚â´ compP.{v}) := by
  dsimp only [dependent, PtpEquiv.snd]
  rw [Universe.compDomEquiv.dependent_eq _ _ _, ‚Üê toCoreAsSmallEquiv_apply_comp_left]
  subst eq
  rw! [‚Üê fst_forgetToGrpd]
  simp [map_id_eq]

theorem dependent_heq : HEq (dependent ab) (U.PtpEquiv.snd (ab ‚â´ compP.{v})) := by
  rw [dependent_eq]
  apply Functor.precomp_heq_of_heq_id
  ¬∑ rw [fst_forgetToGrpd]
  ¬∑ rw [fst_forgetToGrpd]
  ¬∑ apply map_eqToHom_heq_id_cod

theorem fst_naturality : fst (œÉ ‚â´ ab) = œÉ ‚ãô fst ab := by
  dsimp only [fst]
  rw [Universe.compDomEquiv.fst_comp, Grpd.comp_eq_comp,
    toCoreAsSmallEquiv_apply_comp_left]

theorem dependent_comp : dependent (œÉ ‚â´ ab) =
    map (eqToHom (by rw [fst_naturality, Functor.assoc]))
    ‚ãô pre _ œÉ ‚ãô dependent ab := by
  rw [dependent, dependent,
    ‚Üê Universe.compDomEquiv.comp_dependent (eq1 := rfl)
      (eq2 := by erw [‚Üê compDomEquiv.fst_comp_assoc, fst, toCoreAsSmallEquiv.eq_symm_apply]; rfl),
    substWk_eq]
  rfl

theorem snd_comp : snd (œÉ ‚â´ ab) = œÉ ‚ãô snd ab := by
  dsimp only [snd]
  rw [Universe.compDomEquiv.snd_comp, Grpd.comp_eq_comp,
    toCoreAsSmallEquiv_apply_comp_left]

/-- First component of the computation rule for `mk`. -/
theorem fst_mk (Œ± : Œì ‚•§ PGrpd.{v,v}) (A := Œ± ‚ãô PGrpd.forgetToGrpd)
    (hA : Œ± ‚ãô PGrpd.forgetToGrpd = A := by rfl)
    (B : ‚à´(A) ‚•§ Grpd.{v,v})
    (Œ≤ : Œì ‚•§ PGrpd.{v,v}) (h : Œ≤ ‚ãô PGrpd.forgetToGrpd = sec _ Œ± hA ‚ãô B) :
    fst (mk Œ± A hA B Œ≤ h) = Œ± := by
  simp [fst, mk, Universe.compDomEquiv.fst_mk]

/-- Second component of the computation rule for `mk`. -/
theorem dependent_mk (Œ± : Œì ‚•§ PGrpd.{v,v}) (A := Œ± ‚ãô PGrpd.forgetToGrpd)
    (hA : Œ± ‚ãô PGrpd.forgetToGrpd = A := by rfl)
    (B : ‚à´(A) ‚•§ Grpd.{v,v})
    (Œ≤ : Œì ‚•§ PGrpd.{v,v}) (h : Œ≤ ‚ãô PGrpd.forgetToGrpd = sec _ Œ± hA ‚ãô B) :
    dependent (mk Œ± A hA B Œ≤ h) = map (eqToHom (by subst hA; rw [fst_mk])) ‚ãô B := by
  dsimp [dependent, mk]
  rw [Equiv.apply_eq_iff_eq_symm_apply]
  rw [compDomEquiv.dependent_mk]
  ¬∑ rw [toCoreAsSmallEquiv_symm_apply_comp_left]
    erw [eqToHom_eq_homOf_map]
    rfl
  ¬∑ simp [fst, compDomEquiv.fst_mk, hA]

/-- Second component of the computation rule for `mk`. -/
theorem snd_mk (Œ± : Œì ‚•§ PGrpd.{v,v}) (A := Œ± ‚ãô PGrpd.forgetToGrpd)
    (hA : Œ± ‚ãô PGrpd.forgetToGrpd = A := by rfl)
    (B : ‚à´(A) ‚•§ Grpd.{v,v})
    (Œ≤ : Œì ‚•§ PGrpd.{v,v}) (h : Œ≤ ‚ãô PGrpd.forgetToGrpd = sec _ Œ± hA ‚ãô B) :
    snd (mk Œ± A hA B Œ≤ h) = Œ≤ := by
  dsimp [snd, mk]
  rw [Universe.compDomEquiv.snd_mk]
  simp

theorem ext (ab1 ab2 : Œì ‚ü∂ U.compDom.{v})
    (hfst : fst ab1 = fst ab2)
    (hdependent : dependent ab1 = map (eqToHom (by rw [hfst])) ‚ãô dependent ab2)
    (hsnd : snd ab1 = snd ab2) : ab1 = ab2 := by
  dsimp only [compDom] at ab1
  have h1 : compDomEquiv.fst ab1 = compDomEquiv.fst ab2 := by
    apply toCoreAsSmallEquiv.injective
    assumption
  fapply compDomEquiv.ext rfl h1
  ¬∑ dsimp [dependent, fst] at hdependent
    apply toCoreAsSmallEquiv.injective
    convert hdependent
    ¬∑ rw [toCoreAsSmallEquiv_symm_apply_comp_right]
      simp; rfl
    rw! (castMode := .all) [toCoreAsSmallEquiv_symm_apply_comp_right,
      Equiv.symm_apply_apply, h1, hfst]
    simp [map_id_eq]
    congr 1
    simp [‚Üê heq_eq_eq]
    rfl
  ¬∑ apply toCoreAsSmallEquiv.injective
    assumption

theorem hext (ab1 ab2 : Œì ‚ü∂ U.compDom.{v})
    (hfst : fst ab1 = fst ab2) (hdependent : HEq (dependent ab1) (dependent ab2))
    (hsnd : snd ab1 = snd ab2) : ab1 = ab2 := by
  apply ext
  ¬∑ rw! [hdependent]
    simp [‚Üê heq_eq_eq]
    conv => right; rw! (castMode := .all) [hfst]
    simp [map_id_eq]
  ¬∑ assumption
  ¬∑ assumption

end compDom

end U
end

end GroupoidModel

end
