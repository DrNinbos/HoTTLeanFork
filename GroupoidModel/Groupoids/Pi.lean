import GroupoidModel.Groupoids.Sigma
import GroupoidModel.Syntax.NaturalModel
import GroupoidModel.ForMathlib.CategoryTheory.Whiskering
import GroupoidModel.ForMathlib.CategoryTheory.NatTrans

universe v u v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ v‚ÇÉ u‚ÇÉ

noncomputable section
-- NOTE temporary section for stuff to be moved elsewhere
section ForOther

lemma hcongr_fun {Œ± Œ±' : Type u} (hŒ± : Œ± ‚âç Œ±') (Œ≤ : Œ± ‚Üí Type v) (Œ≤' : Œ±' ‚Üí Type v) (hŒ≤ : Œ≤ ‚âç Œ≤')
    (f : (x : Œ±) ‚Üí Œ≤ x) (f' : (x : Œ±') ‚Üí Œ≤' x) (hf : f ‚âç f')
    {x : Œ±} {x' : Œ±'} (hx : x ‚âç x') : f x ‚âç f' x' := by
  subst hŒ± hŒ≤ hf hx
  rfl

namespace CategoryTheory

open Functor

lemma Grpd.Functor.hcongr_obj {C C' D D' : Grpd.{v,u}} (hC : C = C') (hD : D = D')
    {F : C ‚•§ D} {F' : C' ‚•§ D'} (hF : F ‚âç F') {x} {x'} (hx : x ‚âç x') :
    HEq (F.obj x) (F'.obj x') := by
  subst hC hD hF hx
  rfl

lemma Grpd.whiskerLeft_hcongr_right {C D : Type*} [Category C] [Category D]
    {E E' : Grpd.{v,u}} (hE : E ‚âç E') (F : C ‚•§ D) {G H : D ‚•§ E} {G' H' : D ‚•§ E'}
    (hG : G ‚âç G') (hH : H ‚âç H') {Œ± : G ‚ü∂ H} {Œ±' : G' ‚ü∂ H'} (hŒ± : Œ± ‚âç Œ±') :
    whiskerLeft F Œ± ‚âç whiskerLeft F Œ±' := by
  subst hE hG hH hŒ±
  rfl

lemma Grpd.comp_hcongr {C C' D D' E E' : Grpd.{v,u}} (hC : C ‚âç C') (hD : D ‚âç D')
    (hE : E ‚âç E') {F : C ‚•§ D} {F' : C' ‚•§ D'} {G : D ‚•§ E} {G' : D' ‚•§ E'}
    (hF : F ‚âç F') (hG : G ‚âç G')
    : F ‚ãô G ‚âç F' ‚ãô G' := by
  subst hC hD hE hF hG
  rfl

lemma Grpd.NatTrans.hext {X X' Y Y' : Grpd.{v,u}} (hX : X = X') (hY : Y = Y')
    {F G : X ‚•§ Y} {F' G' : X' ‚•§ Y'} (hF : F ‚âç F') (hG : G ‚âç G')
    (Œ± : F ‚ü∂ G) (Œ±' : F' ‚ü∂ G') (happ : ‚àÄ x : X, Œ±.app x ‚âç Œ±'.app ((eqToHom hX).obj x)) :
    Œ± ‚âç Œ±' := by
  subst hX hY hF hG
  aesop_cat

section
variable {A B : Type*} [Category A] [Category B] (F : B ‚•§ A)

-- NOTE to follow mathlib convention can use camelCase for definitions, and capitalised first letter when that definition is a Prop or Type
def IsSection (s : A ‚•§ B) := s ‚ãô F = Functor.id A

abbrev Section := ObjectProperty.FullSubcategory (IsSection F)

instance Section.category : Category (Section F) :=
  ObjectProperty.FullSubcategory.category (IsSection F)

abbrev Section.Œπ : Section F ‚•§ (A ‚•§ B) :=
  ObjectProperty.Œπ (IsSection F)

end

namespace ObjectProperty

-- JH: after the golfs, we don't acuse this lemma anymore,
-- but it is still probably useful?
lemma Œπ_mono {T C : Type u} [Category.{v} C] [Category.{v} T]
    {Z : C ‚Üí Prop} (f g : T ‚•§ FullSubcategory Z)
    (e : f ‚ãô Œπ Z = g ‚ãô Œπ Z) : f = g := by
  apply CategoryTheory.Functor.ext_of_iso _ _ _
  ¬∑ exact Functor.fullyFaithfulCancelRight (Œπ Z) (eqToIso e)
  ¬∑ intro X
    ext
    exact Functor.congr_obj e X
  ¬∑ intro X
    simp only [Functor.fullyFaithfulCancelRight_hom_app, Functor.preimage, Œπ_obj, Œπ_map,
      eqToIso.hom, eqToHom_app, Functor.comp_obj, Classical.choose_eq]
    rfl


end ObjectProperty

instance {C : Type*} [Groupoid C] (P : ObjectProperty C) :
    Groupoid (P.FullSubcategory) :=
  InducedCategory.groupoid C (ObjectProperty.Œπ _).obj

instance Grpd.Œπ_mono (G : Grpd) (P : ObjectProperty G) : Mono (Grpd.homOf (ObjectProperty.Œπ P)) :=
  ‚ü® fun _ _ e => ObjectProperty.Œπ_mono _ _ e ‚ü©

-- lemma Grpd.ObjectProperty.fullSubcategory_heq {A A' : Grpd.{v,u}} (hA : A ‚âç A')
--     (P : ObjectProperty A) (P' : ObjectProperty A') (hP : ‚àÄ x : A, P x ‚Üî P' (hA.elim x)) :
--     (‚ü® ObjectProperty.FullSubcategory P, inferInstance ‚ü© : Grpd) ‚âç
--     (‚ü® ObjectProperty.FullSubcategory P', inferInstance ‚ü© : Grpd) := by
--   subst hA
--   have : P = P' := by aesop
--   rw [this]

lemma Grpd.ObjectProperty.FullSubcategory.hext {A A' : Grpd.{v,u}} (hA : A ‚âç A')
    (P : ObjectProperty A) (P' : ObjectProperty A') (hP : P ‚âç P')
    (a : A) (a' : A') (ha : a ‚âç a') (ha : P a) (ha' : P' a') :
    (‚ü® a, ha ‚ü© : P.FullSubcategory) ‚âç (‚ü® a', ha' ‚ü© : P'.FullSubcategory) := by
  subst hA ha hP
  rfl

end CategoryTheory

end ForOther

-- NOTE content for this doc starts here
namespace GroupoidModel

open CategoryTheory NaturalModelBase Opposite Grothendieck.Groupoidal  Groupoid

attribute [local simp] eqToHom_map Grpd.id_eq_id Grpd.comp_eq_comp Functor.id_comp Functor.comp_id


-- @yiming can we remove this?
/-
   Uncomment this to see the the flow of organizing Conjugation into the Conjugating functor.
   def Conjugating0 {Œì : Grpd.{v,u}} (A B : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ})
    {x y: Œì } (f: x ‚ü∂ y) : (A.obj x‚•§ B.obj x) ‚•§ (A.obj y‚•§ B.obj y) :=
     let wr : B.obj x ‚•§ B.obj y := B.map f
     let wl : A.obj y ‚•§ A.obj x := A.map (Groupoid.inv f)
     let f1_ty : (A.obj y ‚•§ A.obj x) ‚•§ ((A.obj x) ‚•§ (B.obj x)) ‚•§ (A.obj y) ‚•§  (B.obj x) :=
       whiskeringLeft (A.obj y) (A.obj x) (B.obj x)
     let f1 : ((A.obj x) ‚•§ (B.obj x)) ‚•§ (A.obj y) ‚•§  (B.obj x) :=
       (whiskeringLeft (A.obj y) (A.obj x) (B.obj x)).obj (A.map (Groupoid.inv f))
     let f2_ty :  ((B.obj x) ‚•§ (B.obj y)) ‚•§ (A.obj y ‚•§ B.obj x) ‚•§ (A.obj y) ‚•§  (B.obj y) :=
       whiskeringRight (A.obj y) (B.obj x) (B.obj y)
     let f2 : (A.obj y ‚•§ B.obj x) ‚•§ (A.obj y) ‚•§  (B.obj y) :=
       (whiskeringRight (A.obj y) (B.obj x) (B.obj y)).obj (B.map f)
     let f3 := f1 ‚ãô f2
     f3
-/

namespace FunctorOperation
section

open CategoryTheory.Functor

variable {Œì : Type u‚ÇÇ} [Groupoid.{v‚ÇÇ} Œì] (A B : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ})

/--
The functor that, on objects `G : A.obj x ‚•§ B.obj x` acts by
creating the map on the right,
by taking the inverse of `f : x ‚ü∂ y` in the groupoid
         A f
  A x --------> A y
   |             .
   |             |
   |             .
G  |             | conjugating A B f G
   |             .
   V             V
  B x --------> B y
         B f
-/
def conjugating {x y : Œì} (f : x ‚ü∂ y) : (A.obj x ‚•§ B.obj x) ‚•§ (A.obj y ‚•§ B.obj y) :=
  whiskeringLeftObjWhiskeringRightObj (A.map (CategoryTheory.inv f)) (B.map f)

@[simp] lemma conjugating_obj {x y : Œì} (f : x ‚ü∂ y) (s : A.obj x ‚•§ B.obj x) :
    (conjugating A B f).obj s = CategoryTheory.inv (A.map f) ‚ãô s ‚ãô B.map f := by
  simp [conjugating]

@[simp] lemma conjugating_map {x y : Œì} (f : x ‚ü∂ y) {s1 s2 : A.obj x ‚•§ B.obj x} (h : s1 ‚ü∂ s2) :
    (conjugating A B f).map h
    = whiskerRight (whiskerLeft (A.map (CategoryTheory.inv f)) h) (B.map f) := by
  simp [conjugating]

@[simp] lemma conjugating_id (x : Œì) : conjugating A B (ùüô x) = ùü≠ _ := by
  simp [conjugating]

@[simp] lemma conjugating_comp (x y z : Œì) (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    conjugating A B (f ‚â´ g) = conjugating A B f ‚ãô conjugating A B g := by
  simp [conjugating]

@[simp] lemma conjugating_naturality_map {Œî : Type u‚ÇÉ} [Groupoid.{v‚ÇÉ} Œî] (œÉ : Œî ‚•§ Œì)
    {x y} (f : x ‚ü∂ y) : conjugating (œÉ ‚ãô A) (œÉ ‚ãô B) f = conjugating A B (œÉ.map f) := by
  simp [conjugating]
end

section

variable {Œì : Type u‚ÇÇ} [Category.{v‚ÇÇ} Œì] {A : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}}
  (B : ‚à´(A) ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}) (x : Œì)

abbrev sigma.fstAuxObj : sigmaObj B x ‚•§ A.obj x := forget

open sigma

def piObj : Grpd := Grpd.of (Section (fstAuxObj B x))

end

section
variable {Œì : Type u‚ÇÇ} [Groupoid.{v‚ÇÇ} Œì] (A : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ}) (B : ‚à´(A) ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ})
variable {x y : Œì} (f: x ‚ü∂ y)

open sigma

/--
If `s : piObj B x` then the underlying functor is of the form `s : A x ‚•§ sigma A B x`
and it is a section of the forgetful functor `sigma A B x ‚•§ A x`.
This theorem states that conjugating `A f‚Åª¬π ‚ãô s ‚ãô sigma A B f‚Åª¬π : A y ‚•§ sigma A B y`
using some `f : x ‚ü∂ y` produces a section of the forgetful functor `sigma A B y ‚•§ A y`.
-/
theorem isSection_conjugating_isSection (s : piObj B x) : IsSection (fstAuxObj B y)
    ((Section.Œπ (fstAuxObj B x) ‚ãô conjugating A (sigma A B) f).obj s) := by
  simp only [IsSection, Functor.comp_obj, ObjectProperty.Œπ_obj,
    conjugating_obj, Functor.assoc]
  convert_to CategoryTheory.inv (A.map f) ‚ãô (s.obj ‚ãô fstAuxObj B x) ‚ãô A.map f = _
  rw [s.property]
  simp only [Functor.id_comp, ‚Üê Grpd.comp_eq_comp, IsIso.inv_hom_id, Grpd.id_eq_id]

/-- The functorial action of `pi` on a morphism `f : x ‚ü∂ y` in `Œì`
is given by "conjugation".
Since `piObj B x` is a full subcategory of `sigma A B x ‚•§ A x`,
we obtain the action `piMap : piObj B x ‚•§ piObj B y`
as the induced map in the following diagram
          the inclusion
           Section.Œπ
   piObj B x   ‚•§   (A x ‚•§ sigma A B x)
     ‚ãÆ                     ||
     ‚ãÆ                     || conjugating A (sigma A B) f
     VV                     VV
   piObj B y   ‚•§   (A y ‚•§ sigma A B y)
-/
def piMap : piObj B x ‚•§ piObj B y :=
  ObjectProperty.lift (IsSection (fstAuxObj B y))
  ((Section.Œπ (fstAuxObj B x) ‚ãô conjugating A (sigma A B) f))
  (isSection_conjugating_isSection A B f)

lemma piMap_obj_obj (s: piObj B x) : ((piMap A B f).obj s).obj =
    (conjugating A (sigma A B) f).obj s.obj := rfl

lemma piMap_map (s1 s2: piObj B x) (Œ∑: s1 ‚ü∂ s2) :
    (piMap A B f).map Œ∑ = (conjugating A (sigma A B) f).map Œ∑ :=
  rfl

/--
The square commutes

   piObj B x   ‚•§   (A x ‚•§ sigma A B x)
     ‚ãÆ                     ||
piMap‚ãÆ                     || conjugating A (sigma A B) f
     VV                     VV
   piObj B y   ‚•§   (A y ‚•§ sigma A B y)
-/
lemma piMap_Œπ : piMap A B f ‚ãô Section.Œπ (fstAuxObj B y)
    = Section.Œπ (fstAuxObj B x) ‚ãô conjugating A (sigma A B) f :=
  rfl

@[simp] lemma piMap_id (x : Œì) : piMap A B (ùüô x) = ùü≠ (piObj B x) := by
  simp only [piMap, conjugating_id]
  rfl

lemma piMap_comp {x y z : Œì} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    piMap A B (f ‚â´ g) = (piMap A B f) ‚ãô (piMap A B g) := by
  simp only [piMap, conjugating_comp]
  rfl

/-- The formation rule for Œ†-types for the natural model `smallU`
  as operations between functors -/
@[simps] def pi : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ} where
  obj x := piObj B x
  map := piMap A B
  map_id := piMap_id A B
  map_comp := piMap_comp A B

end

section

variable {Œì : Type u‚ÇÇ} [Groupoid.{v‚ÇÇ} Œì] (A : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ}) (B : ‚à´(A) ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ})
  {Œî : Type u‚ÇÉ} [Groupoid.{v‚ÇÉ} Œî] (œÉ : Œî ‚•§ Œì)

theorem IsSection_eq (x) : sigma.fstAuxObj B (œÉ.obj x)
    ‚âç sigma.fstAuxObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x := by
  dsimp [sigma.fstAuxObj, sigmaObj]
  rw [sigma_naturality_aux]

theorem pi_naturality_obj (x) :
    (œÉ ‚ãô pi A B).obj x = (pi (œÉ ‚ãô A) (pre A œÉ ‚ãô B)).obj x := by
  dsimp [pi, piObj, sigma.fstAuxObj, sigmaObj]
  rw [sigma_naturality_aux]

lemma piObj_naturality (x):
  piObj B (œÉ.obj x) = piObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x := by
  dsimp [pi, piObj, sigma.fstAuxObj, sigmaObj]
  rw [sigma_naturality_aux]




lemma eqToHom_eq_homOf_map' {Œì : Type*} [Groupoid Œì] {F G : Œì ‚•§ Grpd} (h : F = G) :
    eqToHom (by rw [h]) = Grpd.homOf (map (eqToHom h)) := by
  subst h
  fapply CategoryTheory.Functor.ext
  ¬∑ intro x
    apply obj_hext
    ¬∑ simp
    ¬∑ simp
  ¬∑ intro x y f
    rw! [Grothendieck.Groupoidal.map_id_eq]
    simp


    /-
    Œî ------pi (œÉ ‚ãô A) (pre A œÉ ‚ãô B)-------> Grpd
    |                                           |
    |                                           |
    œÉ                                           |
    |                                           |
    v                                           v
    Œì -------pi A B -------------------------> Grpd

    -/



section

variable (x y : Œî )
lemma comp_obj_eq (x): A.obj (œÉ.obj x) = (œÉ ‚ãô A).obj x := rfl

def funcEqWhisker1 (x) : (((œÉ ‚ãô A).obj x) ‚•§ sigmaObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x)‚•§
    (A.obj (œÉ.obj x)) ‚•§ sigmaObj B (œÉ.obj x) :=
    (CategoryTheory.Functor.whiskeringRight _ _ _ ).obj
    (map (eqToHom (sigma_naturality_aux B œÉ x)))





-- lemma eqToHom_Œπ1 {x } :
--  eqToHom (pi_naturality_obj A B Œî œÉ x).symm ‚ãô
--  ObjectProperty.Œπ (IsSection (sigma.fstAuxObj B (œÉ.obj x))) =
--  ObjectProperty.Œπ (IsSection (sigma.fstAuxObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) x)) ‚ãô
--  funcEqWhisker1 A B Œî œÉ  (x) :=



--  sorry

lemma eqToHom_Œπ_aux :
    Grpd.of ((A.obj (œÉ.obj x)) ‚•§ ‚à´(Œπ A (œÉ.obj x) ‚ãô B))
    = Grpd.of (A.obj (œÉ.obj x) ‚•§ ‚à´(Œπ (œÉ ‚ãô A) x ‚ãô pre A œÉ ‚ãô B)) :=
  by rw [sigma_naturality_aux]

lemma ObjectProperty.eqToHom_comp_Œπ {C D : Grpd} (h : C = D) (P : ObjectProperty C)
    (Q : ObjectProperty D) (hP : P ‚âç Q) :
    let h' : Grpd.of P.FullSubcategory = Grpd.of Q.FullSubcategory := by
      subst h hP; rfl
    eqToHom h' ‚ãô (ObjectProperty.Œπ Q) = (ObjectProperty.Œπ P) ‚ãô eqToHom h := by
  subst h hP; rfl

lemma eqToHom_Œπ (x) :
    eqToHom (pi_naturality_obj A B œÉ x) ‚ãô
    ObjectProperty.Œπ (IsSection (sigma.fstAuxObj (pre A œÉ ‚ãô B) x)) =
    ObjectProperty.Œπ (IsSection (sigma.fstAuxObj B (œÉ.obj x))) ‚ãô
    eqToHom (eqToHom_Œπ_aux A B œÉ x) := by
  apply ObjectProperty.eqToHom_comp_Œπ (eqToHom_Œπ_aux A B œÉ x)
  dsimp [sigma.fstAuxObj, sigmaObj]
  rw [sigma_naturality_aux]

def funcEqWhisker :
    ((A.obj (œÉ.obj x)) ‚•§ ‚à´(Œπ A (œÉ.obj x) ‚ãô B)) -- parentheses here
    ‚•§ (A.obj (œÉ.obj x)) ‚•§ ‚à´(Œπ (œÉ ‚ãô A) x ‚ãô pre A œÉ ‚ãô B) :=
    (Functor.whiskeringRight (A.obj (œÉ.obj x)) (‚à´(Œπ A (œÉ.obj x) ‚ãô B)) ‚à´(Œπ (œÉ ‚ãô A) x ‚ãô pre A œÉ ‚ãô B)).obj
     (map (eqToHom (sigma_naturality_aux B œÉ x).symm))
end

section
variable  {C : Type u} [Category.{v} C] {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (P Q : ObjectProperty D)
  (F : C ‚•§ D) (hF : ‚àÄ X, P (F.obj X))

theorem FullSubcategory.lift_comp_inclusion_eq :
    P.lift F hF ‚ãô P.Œπ = F :=
  rfl

end


lemma eqToHom_conjugating {x y} (f : x ‚ü∂ y):
    eqToHom (eqToHom_Œπ_aux A B œÉ x) ‚â´ conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (pre A œÉ ‚ãô B)) f =
    conjugating A (sigma A B) (œÉ.map f) ‚â´ eqToHom (eqToHom_Œπ_aux A B œÉ y) := by
  conv => left; right; rw! (castMode := .all) [‚Üê sigma_naturality]
  simp only [Functor.comp_obj, conjugating_naturality_map]
  apply eq_of_heq
  rw [heq_comp_eqToHom_iff] -- HEq tactic please
  apply HEq.trans (eqToHom_comp_heq _ _)
  simp


lemma comm_sq_of_comp_mono {C : Type*} [Category C]
    {X Y Z W X' Y' Z' W' : C}
    (f : X ‚ü∂ Y) (h : X ‚ü∂ W) (g : Y ‚ü∂ Z) (i : W ‚ü∂ Z)
    (f' : X' ‚ü∂ Y') (h' : X' ‚ü∂ W') (g' : Y' ‚ü∂ Z') (i' : W' ‚ü∂ Z')
    (mX : X ‚ü∂ X') (mY : Y ‚ü∂ Y') (mW : W ‚ü∂ W') (mZ : Z ‚ü∂ Z')
    (hbot : f' ‚â´ g' = h' ‚â´ i')
    (hf : f ‚â´ mY = mX ‚â´ f')
    (hh : h ‚â´ mW = mX ‚â´ h')
    (hg : g ‚â´ mZ = mY ‚â´ g')
    (hi : i ‚â´ mZ = mW ‚â´ i')
    [e : Mono mZ]
    : f ‚â´ g = h ‚â´ i := by
  apply e.right_cancellation
  calc (f ‚â´ g) ‚â´ mZ
    _ = f ‚â´ g ‚â´ mZ := by aesop
    _ = f ‚â´ mY ‚â´ g' := by aesop
    _ = (f ‚â´ mY) ‚â´ g' := by simp
    _  = (mX ‚â´ f') ‚â´ g' := by aesop
    _  = mX ‚â´ f' ‚â´ g' := by simp
    _  = mX ‚â´ h' ‚â´ i' := by aesop
    _  = (mX ‚â´ h') ‚â´ i' := by simp
    _  = (h ‚â´ mW) ‚â´ i' := by aesop
    _  = h ‚â´ mW ‚â´ i' := by simp
    _  = h ‚â´ i ‚â´ mZ := by aesop
    _  = (h ‚â´ i) ‚â´ mZ := by aesop



theorem pi_naturality_map {x y} (f : x ‚ü∂ y) :
    Grpd.homOf (piMap A B (œÉ.map f)) ‚â´ eqToHom (pi_naturality_obj A B œÉ y)
    = eqToHom (pi_naturality_obj A B œÉ x) ‚â´ (Grpd.homOf (piMap (œÉ ‚ãô A) (pre A œÉ ‚ãô B) f)) := by
  apply comm_sq_of_comp_mono (e := Grpd.Œπ_mono (Grpd.of (_ ‚•§ _))
      (IsSection (sigma.fstAuxObj (Grothendieck.Groupoidal.pre A œÉ ‚ãô B) y)))
    (Grpd.homOf (piMap A B (œÉ.map f)))
    (eqToHom (pi_naturality_obj A B œÉ x))
    (eqToHom (pi_naturality_obj A B œÉ y)) (Grpd.homOf (piMap (œÉ ‚ãô A) (pre A œÉ ‚ãô B) f))
    (Grpd.homOf (conjugating A (sigma A B) (œÉ.map f)))
    (eqToHom (eqToHom_Œπ_aux A B œÉ x)) (eqToHom (eqToHom_Œπ_aux A B œÉ y))
    (Grpd.homOf (conjugating (œÉ ‚ãô A) (sigma (œÉ ‚ãô A) (pre A œÉ ‚ãô B)) f))
    (Grpd.homOf (ObjectProperty.Œπ _))
    (Grpd.homOf (ObjectProperty.Œπ _))
    (Grpd.homOf (ObjectProperty.Œπ _))
    (Grpd.homOf (ObjectProperty.Œπ _))
  ¬∑ rw [eqToHom_conjugating]
  ¬∑ apply FunctorOperation.FullSubcategory.lift_comp_inclusion_eq
  ¬∑ apply eqToHom_Œπ
  ¬∑ apply eqToHom_Œπ
  ¬∑ apply FunctorOperation.FullSubcategory.lift_comp_inclusion_eq

theorem pi_naturality : œÉ ‚ãô pi A B = pi (œÉ ‚ãô A) (pre A œÉ ‚ãô B) := by
  fapply CategoryTheory.Functor.ext
  ¬∑ apply pi_naturality_obj
  ¬∑ intro x y f
    erw [‚Üê Category.assoc, ‚Üê pi_naturality_map]
    simp [- Grpd.comp_eq_comp, - Grpd.id_eq_id]

end



namespace pi

variable {Œì : Type u‚ÇÇ} [Groupoid.{v‚ÇÇ} Œì] {A : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ}} (B : ‚à´(A) ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ})
  (f : Œì ‚•§ PGrpd.{u‚ÇÅ,u‚ÇÅ}) (hf : f ‚ãô PGrpd.forgetToGrpd = pi A B)

-- -- NOTE: it seems like we need a 2-categorical version of Grothendieck.map
-- -- so the following should be replaced with something like
-- -- `secAux : CategoryTheory.Oplax.OplaxTrans A (sigma A B)`
-- def secAux : A ‚ü∂ sigma A B where
--   app x := (PGrpd.objFiber' hf x).obj
--   naturality x y g := by
--     have h : (((pi A B).map g).obj (PGrpd.objFiber' hf x)).obj ‚ü∂ (PGrpd.objFiber' hf y).obj :=
--       PGrpd.mapFiber' hf g
--     simp [piMap_obj_obj] at h
--     simp

--     sorry

-- def secFib (x) : A.obj x ‚•§ ‚à´(sigma A B) := (PGrpd.objFiber' hf x).obj ‚ãô Œπ (sigma A B) x

-- def secHom {x y} (g : x ‚ü∂ y) : secFib B f hf x ‚ü∂ A.map g ‚ãô secFib B f hf y := by
--   have h : (((pi A B).map g).obj (PGrpd.objFiber' hf x)).obj ‚ü∂ (PGrpd.objFiber' hf y).obj :=
--       PGrpd.mapFiber' hf g
--   simp [piMap_obj_obj] at h
--   simp [secFib]
--   sorry

-- NOTE: this should be defined as something like `Grothendieck.Groupoidal.mapOplax secAux`
def sec : ‚à´(A) ‚•§ ‚à´(sigma A B) :=
  map sorry
  -- have h (x) := (PGrpd.objFiber' hf x).obj
  -- exact functorTo forget (fun x => (h x.base).obj x.fiber) sorry sorry sorry
  -- exact functorFrom (secFib B f hf) (fun {x y} g => sorry) sorry sorry

/--  Let `Œì` be a category.
For any pair of functors `A : Œì ‚•§ Grpd` and `B : ‚à´(A) ‚•§ Grpd`,
and any "term of pi", meaning a functor `f : Œì ‚•§ PGrpd`
satisfying `f ‚ãô forgetToGrpd = pi A B : Œì ‚•§ Grpd`,
there is a "term of `B`" `sec' : Œì ‚•§ PGrpd` such that `sec' ‚ãô forgetToGrpd = B`.
-/
def sec' : ‚à´(A) ‚•§ PGrpd := sorry ‚ãô sigma.assoc B ‚ãô toPGrpd B

def sec_forgetToGrpd : sec' B ‚ãô PGrpd.forgetToGrpd = B := sorry

end pi

section

variable {Œì : Type u‚ÇÇ} [Groupoid.{v‚ÇÇ} Œì] (A : Œì ‚•§ Grpd.{u‚ÇÅ,u‚ÇÅ}) (Œ≤ : ‚à´(A) ‚•§ PGrpd.{u‚ÇÅ,u‚ÇÅ})

section
variable (x : Œì)

def lamFibObjObj : Grpd.of (A.obj x ‚•§ sigmaObj (Œ≤ ‚ãô PGrpd.forgetToGrpd) x) :=
  sec (Œπ A x ‚ãô Œ≤ ‚ãô PGrpd.forgetToGrpd) (Œπ A x ‚ãô Œ≤) rfl

@[simp] lemma lamFibObjObj_obj_base (a) : ((lamFibObjObj A Œ≤ x).obj a).base = a := by
  simp [lamFibObjObj]

@[simp] lemma lamFibObjObj_obj_fiber (a) : ((lamFibObjObj A Œ≤ x).obj a).fiber
    = PGrpd.objFiber (Œπ A x ‚ãô Œ≤) a := by
  simp [lamFibObjObj]

@[simp] lemma lamFibObjObj_map_base {a a'} (h: a ‚ü∂ a'):
    ((lamFibObjObj A Œ≤ x).map h).base = h := by
  simp [lamFibObjObj]

@[simp] lemma lamFibObjObj_map_fiber {a a'} (h: a ‚ü∂ a'):
    ((lamFibObjObj A Œ≤ x).map h).fiber = PGrpd.mapFiber (Œπ A x ‚ãô Œ≤) h := by
  simp [lamFibObjObj]

def lamFibObj : piObj (Œ≤ ‚ãô PGrpd.forgetToGrpd) x :=
  ‚ü®lamFibObjObj A Œ≤ x , rfl‚ü©

@[simp] lemma lamFibObj_obj : (lamFibObj A Œ≤ x).obj = lamFibObjObj A Œ≤ x :=
  rfl

@[simp] lemma lamFibObj_obj_obj : (lamFibObj A Œ≤ x).obj = lamFibObjObj A Œ≤ x :=
  rfl

end

section
variable {x y : Œì} (f : x ‚ü∂ y)

open CategoryTheory.Functor

def lamFibObjObjCompSigmaMap.app (a : A.obj x) :
    (lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f).obj a ‚ü∂
    (A.map f ‚ãô lamFibObjObj A Œ≤ y).obj a :=
  homMk (ùüô _) (eqToHom (by simp; rfl) ‚â´ (Œ≤.map ((ŒπNatTrans f).app a)).fiber)

@[simp] lemma lamFibObjObjCompSigmaMap.app_base (a : A.obj x) : (app A Œ≤ f a).base = ùüô _ := by
  simp [app]

lemma lamFibObjObjCompSigmaMap.app_fiber_eq (a : A.obj x) : (app A Œ≤ f a).fiber =
    eqToHom (by simp; rfl) ‚â´ (Œ≤.map ((ŒπNatTrans f).app a)).fiber := by
  simp [app]

lemma lamFibObjObjCompSigmaMap.app_fiber_heq (a : A.obj x) : (app A Œ≤ f a).fiber ‚âç
    (Œ≤.map ((ŒπNatTrans f).app a)).fiber := by
  simp [app]

lemma lamFibObjObjCompSigmaMap.naturality {x y : Œì} (f : x ‚ü∂ y) {a1 a2 : A.obj x} (h : a1 ‚ü∂ a2) :
    (lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f).map h
    ‚â´ lamFibObjObjCompSigmaMap.app A Œ≤ f a2 =
    lamFibObjObjCompSigmaMap.app A Œ≤ f a1
    ‚â´ (A.map f ‚ãô lamFibObjObj A Œ≤ y).map h := by
  apply Grothendieck.Groupoidal.hext
  ¬∑ simp [sigmaObj]
  ¬∑ have Œ≤_ŒπNatTrans_naturality : Œ≤.map ((Œπ A x).map h) ‚â´ Œ≤.map ((ŒπNatTrans f).app a2)
        = Œ≤.map ((ŒπNatTrans f).app a1) ‚â´ Œ≤.map ((A.map f ‚ãô Œπ A y).map h) := by
      simp [‚Üê Functor.map_comp, (ŒπNatTrans f).naturality h]
    have h_naturality : (Œ≤.map ((ŒπNatTrans f).app a2)).base.map (Œ≤.map ((Œπ A x).map h)).fiber
        ‚â´ (Œ≤.map ((ŒπNatTrans f).app a2)).fiber ‚âç
        (Œ≤.map ((Œπ A y).map ((A.map f).map h))).base.map (Œ≤.map ((ŒπNatTrans f).app a1)).fiber
        ‚â´ (Œ≤.map ((Œπ A y).map ((A.map f).map h))).fiber := by
      simpa [‚Üê heq_eq_eq] using Grothendieck.congr Œ≤_ŒπNatTrans_naturality
    simp only [sigmaObj, Grpd.coe_of, comp_obj, Grothendieck.forget_obj,
      sigmaMap_obj_base, Functor.comp_map, comp_base, sigmaMap_map_base, Grothendieck.forget_map,
      sigmaMap_obj_fiber, comp_fiber, sigmaMap_map_fiber, lamFibObjObj_map_fiber, map_comp,
      eqToHom_map, app_fiber_eq, Category.assoc, eqToHom_trans_assoc,
      heq_eqToHom_comp_iff, eqToHom_comp_heq_iff]
    rw [‚Üê Category.assoc]
    apply HEq.trans _ h_naturality
    apply heq_comp _ rfl rfl _ HEq.rfl
    ¬∑ aesop_cat
    ¬∑ simp only [‚Üê Functor.comp_map, ‚Üê Grpd.comp_eq_comp, comp_eqToHom_heq_iff]
      congr 3
      aesop_cat

@[simp] lemma lamFibObjObjCompSigmaMap.app_id (a) : lamFibObjObjCompSigmaMap.app A Œ≤ (ùüô x) a
    = eqToHom (by simp) := by
  apply Grothendieck.Groupoidal.hext
  ¬∑ simp [sigmaObj]
  ¬∑ simp only [Grpd.forgetToCat.eq_1, sigmaObj, comp_obj, Grothendieck.forget_obj,
      sigmaMap_obj_base, app, Functor.comp_map, Grothendieck.forget_map, sigmaMap_obj_fiber, Cat.of_Œ±,
      id_eq, homMk_base, homMk_fiber, eqToHom_comp_heq_iff]
    rw! (castMode := .all) [ŒπNatTrans_id_app]
    simp only [Grpd.coe_of, comp_obj, Grothendieck.congr (eqToHom_map Œ≤ _),
      Grothendieck.fiber_eqToHom, eqToHom_trans, eqToHom_fiber,
      Grothendieck.forget_obj, sigmaMap_obj_base, Functor.comp_map, Grothendieck.forget_map,
      sigmaMap_obj_fiber, heq_eqRec_iff_heq]
    apply (eqToHom_heq_id_cod _ _ _).trans (eqToHom_heq_id_cod _ _ _).symm

lemma lamFibObjObjCompSigmaMap.app_comp {x y z : Œì} (f : x ‚ü∂ y) (g : y ‚ü∂ z) (a) :
    lamFibObjObjCompSigmaMap.app A Œ≤ (f ‚â´ g) a
    = eqToHom (by simp)
    ‚â´ (sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g).map (app A Œ≤ f a)
    ‚â´ app A Œ≤ g ((A.map f).obj a) ‚â´ eqToHom (by simp) := by
  fapply Grothendieck.Groupoidal.ext
  ¬∑ simp [sigmaObj]
  ¬∑ have h : (Œ≤.map ((ŒπNatTrans (f ‚â´ g)).app a)) = Œ≤.map ((ŒπNatTrans f).app a)
      ‚â´ Œ≤.map ((ŒπNatTrans g).app ((A.map f).obj a))
      ‚â´ eqToHom (by simp) := by
      simp [ŒπNatTrans_comp_app]
    simp only [Grpd.forgetToCat.eq_1, sigmaObj, Grpd.coe_of, comp_obj, Grothendieck.forget_obj,
      sigmaMap_obj_base, app, Functor.comp_map, Grothendieck.forget_map, sigmaMap_obj_fiber,
      Cat.of_Œ±, id_eq, comp_base, sigmaMap_map_base, homMk_base, homMk_fiber, Grothendieck.congr h,
      Grothendieck.comp_base, Grpd.comp_eq_comp, Grothendieck.comp_fiber, eqToHom_refl,
      Grothendieck.fiber_eqToHom, Category.id_comp, eqToHom_trans_assoc, comp_fiber, eqToHom_fiber,
      eqToHom_map, sigmaMap_map_fiber, map_comp, Category.assoc]
    rw! [Grothendieck.eqToHom_base, Category.id_comp, eqToHom_base, eqToHom_base, eqToHom_map,
      eqToHom_map, eqToHom_map, Grothendieck.eqToHom_base]
    aesop_cat

/-
a ---h---> a' in A.obj x

B(x,a) ----> B(y,Afa)
 |               |
 |               |
 v               v
B(x,a')----> B(y,Afa')
-/

def lamFibObjObjCompSigmaMap :
    lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f ‚ü∂
    A.map f ‚ãô lamFibObjObj A Œ≤ y where
  app := lamFibObjObjCompSigmaMap.app A Œ≤ f
  naturality _ _ h := lamFibObjObjCompSigmaMap.naturality A Œ≤ f h

@[simp] lemma lamFibObjObjCompSigmaMap_id (x : Œì) : lamFibObjObjCompSigmaMap A Œ≤ (ùüô x) =
    eqToHom (by simp [sigmaMap_id]) := by
  ext a
  simp [lamFibObjObjCompSigmaMap]

/-
lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) (f ‚â´ g)

_ ‚ü∂ lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g
:= eqToHom ‚ãØ

_ ‚ü∂ A.map f ‚ãô lamFibObjObj A Œ≤ y ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g
:= whiskerRight (lamFibObjObjCompSigmaMap A Œ≤ f) (sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g)

_ ‚ü∂ A.map f ‚ãô A.map g ‚ãô lamFibObjObj A Œ≤ z
:= whiskerLeft (A.map f) (lamFibObjObjCompSigmaMap A Œ≤ g)

_ ‚ü∂ A.map (f ‚â´ g) ‚ãô lamFibObjObj A Œ≤ z
:= eqToHom ‚ãØ

-/

lemma lamFibObjObjCompSigmaMap_comp {x y z : Œì} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    lamFibObjObjCompSigmaMap A Œ≤ (f ‚â´ g) =
    eqToHom (by rw [sigmaMap_comp]; rfl)
    ‚â´ whiskerRight (lamFibObjObjCompSigmaMap A Œ≤ f) (sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g)
    ‚â´ whiskerLeft (A.map f) (lamFibObjObjCompSigmaMap A Œ≤ g)
    ‚â´ eqToHom (by rw [Functor.map_comp, Grpd.comp_eq_comp, Functor.assoc]) := by
  ext a
  simp [lamFibObjObjCompSigmaMap, lamFibObjObjCompSigmaMap.app_comp]

def whiskerLeftInvLamObjObjSigmaMap :
    A.map (CategoryTheory.inv f) ‚ãô lamFibObjObj A Œ≤ x ‚ãô sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) f ‚ü∂
    lamFibObjObj A Œ≤ y :=
  whiskerLeft (A.map (CategoryTheory.inv f)) (lamFibObjObjCompSigmaMap A Œ≤ f)
  ‚â´ eqToHom (by simp [‚Üê Grpd.comp_eq_comp])

@[simp] lemma whiskerLeftInvLamObjObjSigmaMap_id (x : Œì) :
    whiskerLeftInvLamObjObjSigmaMap A Œ≤ (ùüô x) = eqToHom (by simp [sigmaMap_id]) := by
  simp [whiskerLeftInvLamObjObjSigmaMap]

-- TODO find a better proof. This should not need `ext`,
-- instead should be by manipulating whiskerLeft and whiskerRight lemmas
lemma whiskerLeftInvLamObjObjSigmaMap_comp {x y z} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    whiskerLeftInvLamObjObjSigmaMap A Œ≤ (f ‚â´ g)
    = eqToHom (by simp [Functor.assoc, sigmaMap_comp])
    ‚â´ whiskerRight (whiskerLeft (A.map (CategoryTheory.inv g)) (whiskerLeftInvLamObjObjSigmaMap A Œ≤ f))
      (sigmaMap (Œ≤ ‚ãô PGrpd.forgetToGrpd) g)
    ‚â´ whiskerLeftInvLamObjObjSigmaMap A Œ≤ g := by
  simp only [whiskerLeftInvLamObjObjSigmaMap, lamFibObjObjCompSigmaMap_comp]
  rw! [Functor.map_inv, Functor.map_inv, Functor.map_inv,
    Functor.map_comp, IsIso.inv_comp]
  ext
  simp only [Grpd.forgetToCat.eq_1, sigmaObj, Grpd.comp_eq_comp, comp_obj, eqToHom_refl,
    Category.comp_id, whiskerLeft_comp, whiskerLeft_eqToHom, whiskerLeft_twice, Category.assoc,
    NatTrans.comp_app, eqToHom_app, whiskerLeft_app, whiskerRight_app, associator_inv_app,
    associator_hom_app, Category.id_comp, whiskerRight_comp, eqToHom_whiskerRight, map_id]
  congr 2
  simp only [‚Üê comp_obj, Functor.assoc]
  simp only [‚Üê Grpd.comp_eq_comp]
  rw! (castMode := .all) [IsIso.inv_hom_id]
  apply eq_of_heq
  simp [- heq_eq_eq]
  rfl

def lamFibMap :
    ((pi A (Œ≤ ‚ãô PGrpd.forgetToGrpd)).map f).obj (lamFibObj A Œ≤ x) ‚ü∂ lamFibObj A Œ≤ y :=
  whiskerLeftInvLamObjObjSigmaMap A Œ≤ f

@[simp] lemma lamFibMap_id (x : Œì) : lamFibMap A Œ≤ (ùüô x) = eqToHom (by simp) := by
  simp [lamFibMap]
  rfl

lemma lamFibMap_comp {x y z} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    lamFibMap A Œ≤ (f ‚â´ g)
    = eqToHom (by rw [‚Üê Functor.comp_obj]; apply Functor.congr_obj; simp [piMap_comp])
    ‚â´ ((piMap A (Œ≤ ‚ãô PGrpd.forgetToGrpd)) g).map ((lamFibMap A Œ≤) f)
    ‚â´ lamFibMap A Œ≤ g := by
  simp [lamFibMap, piMap, whiskerLeftInvLamObjObjSigmaMap_comp]
  rfl

def lam : Œì ‚•§ PGrpd.{u‚ÇÅ,u‚ÇÅ} :=
  PGrpd.functorTo
  (pi A (Œ≤ ‚ãô PGrpd.forgetToGrpd))
  (lamFibObj A Œ≤)
  (lamFibMap A Œ≤)
  (lamFibMap_id A Œ≤)
  (lamFibMap_comp A Œ≤)

lemma lam_comp_forgetToGrpd : lam A Œ≤ ‚ãô PGrpd.forgetToGrpd = pi A (Œ≤ ‚ãô PGrpd.forgetToGrpd) :=
  rfl

variable {Œî : Type u‚ÇÉ} [Groupoid.{v‚ÇÉ} Œî] (œÉ : Œî ‚•§ Œì)

lemma lam_naturality_aux (x) :
    Œπ A (œÉ.obj x) ‚ãô Œ≤ ‚ãô PGrpd.forgetToGrpd = Œπ (œÉ ‚ãô A) x ‚ãô pre A œÉ ‚ãô Œ≤ ‚ãô PGrpd.forgetToGrpd := by
  simp [‚Üê Functor.assoc, ‚Üê Grothendieck.Groupoidal.Œπ_pre]

lemma lamFibObjObj_naturality (x) :
    lamFibObjObj A Œ≤ (œÉ.obj x) ‚âç lamFibObjObj (œÉ ‚ãô A) (pre A œÉ ‚ãô Œ≤) x := by
  simp only [lamFibObjObj, ‚Üê Œπ_pre, comp_obj, Functor.assoc]
  congr!

lemma lam_naturality_obj_aux (x) :
    Grpd.of (A.obj (œÉ.obj x) ‚•§ sigmaObj (Œ≤ ‚ãô PGrpd.forgetToGrpd) (œÉ.obj x)) ‚âç
    Grpd.of (A.obj (œÉ.obj x) ‚•§ sigmaObj ((pre A œÉ ‚ãô Œ≤) ‚ãô PGrpd.forgetToGrpd) x) := by
  rw [sigmaObj_naturality, Functor.assoc]

theorem lam_naturality_obj (x : Œî) : HEq (lamFibObj A Œ≤ (œÉ.obj x))
    (lamFibObj (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô Œ≤) x) := by
  simp only [lamFibObj]
  apply Grpd.ObjectProperty.FullSubcategory.hext (lam_naturality_obj_aux A Œ≤ œÉ x)
  ¬∑ simp only [sigma.fstAuxObj, Functor.assoc]
    congr!
    any_goals simp [sigmaObj_naturality, lam_naturality_aux]
  ¬∑ apply lamFibObjObj_naturality

lemma lamFibObjObjCompSigmaMap.app_naturality {x y} (f : x ‚ü∂ y) (a) :
    lamFibObjObjCompSigmaMap.app A Œ≤ (œÉ.map f) a ‚âç
    lamFibObjObjCompSigmaMap.app (œÉ ‚ãô A) (pre A œÉ ‚ãô Œ≤) f a := by
  apply Grothendieck.Groupoidal.hext'
  any_goals apply Grpd.Functor.hcongr_obj
  any_goals apply Grpd.comp_hcongr
  any_goals simp only [comp_obj, Functor.comp_map, heq_eq_eq]
  any_goals apply sigmaObj_naturality
  any_goals apply lam_naturality_aux
  any_goals apply sigmaMap_naturality_heq
  any_goals apply lamFibObjObj_naturality
  any_goals simp [app]; rfl

lemma lamFibObjObjCompSigmaMap_naturality {x y} (f : x ‚ü∂ y) :
    lamFibObjObjCompSigmaMap A Œ≤ (œÉ.map f) ‚âç
    lamFibObjObjCompSigmaMap (œÉ ‚ãô A) (pre A œÉ ‚ãô Œ≤) f := by
  apply Grpd.NatTrans.hext
  any_goals apply Grpd.comp_hcongr
  any_goals simp only [comp_obj, Functor.comp_map, heq_eq_eq, eqToHom_refl]
  any_goals apply sigmaObj_naturality
  any_goals apply lamFibObjObj_naturality
  ¬∑ apply sigmaMap_naturality_heq
  ¬∑ apply lamFibObjObjCompSigmaMap.app_naturality

lemma whiskerLeftInvLamObjObjSigmaMap_naturality_heq {x y} (f : x ‚ü∂ y) :
    whiskerLeftInvLamObjObjSigmaMap A Œ≤ (œÉ.map f) ‚âç
    whiskerLeftInvLamObjObjSigmaMap (œÉ ‚ãô A) (pre A œÉ ‚ãô Œ≤) f := by
  simp only [whiskerLeftInvLamObjObjSigmaMap, Functor.comp_map]
  apply HEq.trans (comp_eqToHom_heq _ _)
  apply HEq.trans _ (comp_eqToHom_heq _ _).symm
  rw [Functor.map_inv, Functor.map_inv, Functor.map_inv]
  apply Grpd.whiskerLeft_hcongr_right
  any_goals apply Grpd.comp_hcongr
  any_goals simp only [comp_obj, heq_eq_eq]
  any_goals apply sigmaObj_naturality
  any_goals apply lamFibObjObj_naturality
  ¬∑ apply sigmaMap_naturality_heq
  ¬∑ apply lamFibObjObjCompSigmaMap_naturality

lemma lam_naturality_map {x y} (f : x ‚ü∂ y) :
    lamFibMap A Œ≤ (œÉ.map f) ‚âç lamFibMap (œÉ ‚ãô A) (Grothendieck.Groupoidal.pre A œÉ ‚ãô Œ≤) f := by
  apply whiskerLeftInvLamObjObjSigmaMap_naturality_heq

theorem lam_naturality : œÉ ‚ãô lam A Œ≤ = lam (œÉ ‚ãô A) (pre A œÉ ‚ãô Œ≤)
     := by
  apply PGrpd.Functor.hext
  ¬∑ apply pi_naturality
  ¬∑ apply lam_naturality_obj
  ¬∑ apply lam_naturality_map

end
end

section
variable {Œì : Ctx}

namespace smallUPi

def Pi_app (AB : y(Œì) ‚ü∂ smallU.{v}.Ptp.obj smallU.{v}.Ty) :
    y(Œì) ‚ü∂ smallU.{v}.Ty :=
  yonedaCategoryEquiv.symm (pi _ (smallU.PtpEquiv.snd AB))

def Pi_naturality {Œî Œì} (f : Œî ‚ü∂ Œì) (Œ± : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Ty) :
    Pi_app (ym(f) ‚â´ Œ±) = ym(f) ‚â´ Pi_app Œ± := by
  dsimp only [Pi_app]
  rw [‚Üê yonedaCategoryEquiv_symm_naturality_left, pi_naturality,
    smallU.PtpEquiv.snd_naturality]
  rw! [smallU.PtpEquiv.fst_naturality]
  simp [map_id_eq, Functor.id_comp]

/-- The formation rule for Œ†-types for the natural model `smallU` -/
def Pi : smallU.{v}.Ptp.obj smallU.{v}.Ty ‚ü∂ smallU.{v}.Ty :=
  NatTrans.yonedaMk Pi_app Pi_naturality

lemma Pi_app_eq {Œì : Ctx} (ab : y(Œì) ‚ü∂ _) : ab ‚â´ Pi =
    yonedaCategoryEquiv.symm (FunctorOperation.pi _ (smallU.PtpEquiv.snd ab)) := by
  rw [Pi, NatTrans.yonedaMk_app, Pi_app]

def lam_app (ab : y(Œì) ‚ü∂ smallU.{v}.Ptp.obj smallU.{v}.Tm) :
    y(Œì) ‚ü∂ smallU.{v}.Tm :=
  yonedaCategoryEquiv.symm (lam _ (smallU.PtpEquiv.snd ab))

open smallU.PtpEquiv

def lam_naturality {Œî Œì} (f : Œî ‚ü∂ Œì) (Œ± : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Tm) :
    lam_app (ym(f) ‚â´ Œ±) = ym(f) ‚â´ lam_app Œ± := by
  dsimp only [lam_app]
  rw [‚Üê yonedaCategoryEquiv_symm_naturality_left, FunctorOperation.lam_naturality]
  rw! [snd_naturality, fst_naturality]
  simp [map_id_eq]

/-- The introduction rule for Œ†-types for the natural model `smallU` -/
def lam : smallU.{v}.Ptp.obj smallU.{v}.Tm ‚ü∂ smallU.{v}.Tm :=
  NatTrans.yonedaMk lam_app lam_naturality

lemma lam_app_eq {Œì : Ctx} (ab : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Tm) : ab ‚â´ lam =
    yonedaCategoryEquiv.symm (FunctorOperation.lam _ (smallU.PtpEquiv.snd ab)) := by
  rw [lam, NatTrans.yonedaMk_app, lam_app]

lemma smallU.PtpEquiv.fst_app_comp_map_tp {Œì : Ctx} (ab : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Tm) :
    smallU.PtpEquiv.fst (ab ‚â´ smallU.Ptp.map smallU.tp) = smallU.PtpEquiv.fst ab :=
  sorry

lemma smallU.PtpEquiv.snd_app_comp_map_tp {Œì : Ctx} (ab : y(Œì) ‚ü∂ smallU.Ptp.obj smallU.Tm) :
    smallU.PtpEquiv.snd (ab ‚â´ smallU.Ptp.map smallU.tp)
    ‚âç smallU.PtpEquiv.snd ab ‚ãô PGrpd.forgetToGrpd :=
  sorry

theorem lam_tp : smallUPi.lam ‚â´ smallU.tp = smallU.Ptp.map smallU.tp ‚â´ Pi := by
  apply hom_ext_yoneda
  intros Œì ab
  rw [‚Üê Category.assoc, ‚Üê Category.assoc, lam_app_eq, Pi_app_eq, smallU_tp, œÄ,
    ‚Üê yonedaCategoryEquiv_symm_naturality_right, lam_comp_forgetToGrpd]
  symm; congr 2
  ¬∑ apply smallU.PtpEquiv.fst_app_comp_map_tp
  ¬∑ apply smallU.PtpEquiv.snd_app_comp_map_tp

section
variable {Œì : Ctx} (AB : y(Œì) ‚ü∂ smallU.Ptp.obj.{v} y(U.{v}))
  (Œ±Œ≤ : y(Œì) ‚ü∂ y(E.{v})) (hŒ±Œ≤ : Œ±Œ≤ ‚â´ ym(œÄ) = AB ‚â´ smallUPi.Pi)

include hŒ±Œ≤ in
theorem yonedaCategoryEquiv_forgetToGrpd : yonedaCategoryEquiv Œ±Œ≤ ‚ãô PGrpd.forgetToGrpd
    = pi (smallU.PtpEquiv.fst AB) (smallU.PtpEquiv.snd AB) := by
  erw [‚Üê yonedaCategoryEquiv_naturality_right, hŒ±Œ≤]
  rw [smallUPi.Pi_app_eq, yonedaCategoryEquiv.apply_symm_apply]

def lift : y(Œì) ‚ü∂ smallU.Ptp.obj.{v} smallU.Tm.{v} :=
  let Œ±Œ≤' := yonedaCategoryEquiv Œ±Œ≤
  smallU.PtpEquiv.mk (smallU.PtpEquiv.fst AB) sorry

  -- let Œ≤' := smallU.PtpEquiv.snd AB
  -- let Œ±Œ≤' := yonedaCategoryEquiv Œ±Œ≤
  -- let hŒ±Œ≤' : yonedaCategoryEquiv Œ±Œ≤ ‚ãô forgetToGrpd
  --   = sigma (smallU.PtpEquiv.fst AB) (smallU.PtpEquiv.snd AB) :=
  --   yonedaCategoryEquiv_forgetToGrpd _ _ hŒ±Œ≤
  -- mk (sigma.fst' Œ≤' Œ±Œ≤' hŒ±Œ≤') (sigma.dependent' Œ≤' Œ±Œ≤' hŒ±Œ≤')
  -- (sigma.snd' Œ≤' Œ±Œ≤' hŒ±Œ≤') (sigma.snd'_forgetToGrpd Œ≤' Œ±Œ≤' hŒ±Œ≤')

-- theorem fac_left : lift.{v} AB Œ±Œ≤ hŒ±Œ≤ ‚â´ smallUSigma.pair.{v} = Œ±Œ≤ := by
--   rw [smallUSigma.pair_app_eq]
--   dsimp only [lift]
--   rw! [dependent_mk, snd_mk, fst_mk]
--   simp only [eqToHom_refl, map_id_eq, Cat.of_Œ±, Functor.id_comp]
--   rw [yonedaCategoryEquiv.symm_apply_eq, sigma.eta]

-- theorem fac_right : lift.{v} AB Œ±Œ≤ hŒ±Œ≤ ‚â´ smallU.comp.{v} = AB := by
--   apply smallU.PtpEquiv.hext
--   ¬∑ rw [‚Üê fst_forgetToGrpd]
--     dsimp only [lift]
--     rw [fst_mk, sigma.fst'_forgetToGrpd]
--   ¬∑ apply HEq.trans (dependent_heq _).symm
--     rw [lift, dependent_mk]
--     dsimp [sigma.dependent']
--     simp [map_id_eq, Functor.id_comp]
--     apply map_eqToHom_comp_heq

-- theorem hom_ext (m n : y(Œì) ‚ü∂ smallU.compDom.{v})
--     (hComp : m ‚â´ smallU.comp = n ‚â´ smallU.comp)
--     (hPair : m ‚â´ smallUSigma.pair = n ‚â´ smallUSigma.pair) : m = n := sorry

-- theorem uniq (m : y(Œì) ‚ü∂ smallU.compDom)
--     (hmAB : m ‚â´ smallU.comp = AB) (hmŒ±Œ≤ : m ‚â´ smallUSigma.pair = Œ±Œ≤) :
--     m = lift AB Œ±Œ≤ hŒ±Œ≤ := by
--   apply hom_ext
--   ¬∑ rw [hmAB, fac_right]
--   ¬∑ rw [hmŒ±Œ≤, fac_left]

end
theorem isPullback : IsPullback lam.{v,u} (smallU.Ptp.{v,u}.map smallU.tp)
    smallU.{v, u}.tp Pi.{v, u} :=
  Limits.RepPullbackCone.is_pullback lam_tp
    (fun s => sorry)
    (fun s => sorry)
    (fun s => sorry)
    (fun s m fac_left fac_right => sorry)
  -- Limits.RepPullbackCone.is_pullback smallUSigma.lam_tp.{v,u}
  --   (fun s => lift s.snd s.fst s.condition)
  --   (fun s => fac_left.{v,u} _ _ s.condition)
  --   (fun s => fac_right.{v,u} _ _ s.condition)
  --   (fun s m fac_left fac_right => uniq.{v,u} _ _ s.condition m fac_right fac_left)

end smallUPi

def smallUPi : NaturalModelPi smallU.{v} where
  Pi := smallUPi.Pi.{v}
  lam := smallUPi.lam.{v}
  Pi_pullback := sorry

def uHomSeqPis' (i : ‚Ñï) (ilen : i < 4) :
  NaturalModelPi (uHomSeqObjs i ilen) :=
  match i with
  | 0 => smallUPi.{0,4}
  | 1 => smallUPi.{1,4}
  | 2 => smallUPi.{2,4}
  | 3 => smallUPi.{3,4}
  | (n+4) => by omega

def uHomSeqPis : UHomSeqPiSigma Ctx := { uHomSeq with
  nmPi := uHomSeqPis'
  nmSigma := uHomSeqSigmas' }

end

end FunctorOperation

end GroupoidModel
