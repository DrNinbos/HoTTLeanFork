/-
Copyright (c) 2025 Joseph Hua. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Hua, Sina Hazratpour, Emily Riehl
-/

import Mathlib.CategoryTheory.MorphismProperty.OverAdjunction
import Mathlib.CategoryTheory.Functor.TwoSquare
import Mathlib.CategoryTheory.NatTrans.IsCartesian
import Mathlib.CategoryTheory.Comma.Over.Pushforward

universe v u v‚ÇÅ u‚ÇÅ

noncomputable section

namespace CategoryTheory

open Category Limits MorphismProperty

variable {C : Type u} [Category.{v} C]

namespace MorphismProperty

namespace PolynomialPartialAdjunction

variable {T : Type u} [Category.{v} T] {P : MorphismProperty T}
  [P.HasPullbacks] [P.IsStableUnderBaseChange]
  {Q : MorphismProperty T} [Q.HasPullbacks] [P.HasPushforwards Q]
  [P.IsStableUnderPushforward Q]
  {S S' S'' : T} (i : S ‚ü∂ S') (q : S ‚ü∂(Q) S'')

/-- The partial right adjoint representing a multivariate polynomial. -/
abbrev partialRightAdjoint := Over.pullback P ‚ä§ i ‚ãô pushforward P q

abbrev leftAdjoint := CategoryTheory.Over.pullback q.1 ‚ãô CategoryTheory.Over.map i

/-- `pullback P ‚ä§ i ‚ãô pushforward P q` is a partial right adjoint to
`CategoryTheory.Over.pullback q.1 ‚ãô CategoryTheory.Over.map i`
-/
def homEquiv {X : Over S''} {Y : P.Over ‚ä§ S'} :
    (X ‚ü∂ ((partialRightAdjoint i q).obj Y).toComma) ‚âÉ
    ((leftAdjoint i q).obj X ‚ü∂ Y.toComma) :=
  calc (X ‚ü∂ ((P.pushforward q).obj ((Over.pullback P ‚ä§ i).obj Y)).toComma)
  _ ‚âÉ ((CategoryTheory.Over.pullback q.1).obj X ‚ü∂ ((Over.pullback P ‚ä§ i).obj Y).toComma) :=
    pushforward.homEquiv ..
  _ ‚âÉ ((CategoryTheory.Over.map i).obj
      ((CategoryTheory.Over.pullback q.fst).obj X) ‚ü∂ Y.toComma) :=
    pullback.homEquiv ..

lemma homEquiv_comp {X X' : Over S''} {Y : P.Over ‚ä§ S'}
    (f : X' ‚ü∂ ((partialRightAdjoint i q).obj Y).toComma) (g : X ‚ü∂ X') :
    homEquiv i q (g ‚â´ f) =
    (leftAdjoint i q).map g ‚â´ homEquiv i q f := by
  unfold homEquiv
  simp only [Functor.comp_obj, Equiv.trans_def, Equiv.trans_apply]
  erw [pushforward.homEquiv_comp, pullback.homEquiv_comp]
  rfl

lemma homEquiv_map_comp {X : Over S''} {Y Y' : P.Over ‚ä§ S'}
    (f : X ‚ü∂ ((partialRightAdjoint i q).obj Y).toComma) (g : Y ‚ü∂ Y') :
    homEquiv i q (f ‚â´ Comma.Hom.hom ((partialRightAdjoint i q).map g)) =
    homEquiv i q f ‚â´ Comma.Hom.hom g := by
  unfold homEquiv
  simp only [Functor.comp_obj, Equiv.trans_def, Equiv.trans_apply]
  erw [pushforward.homEquiv_map_comp, pullback.homEquiv_map_comp]
  rfl

lemma homEquiv_symm_comp {X : Over S''} {Y Y' : P.Over ‚ä§ S'}
    (f : (leftAdjoint i q).obj X ‚ü∂ Y.toComma) (g : Y ‚ü∂ Y') :
    (homEquiv i q).symm f ‚â´ Comma.Hom.hom ((partialRightAdjoint i q).map g) =
    (homEquiv i q).symm (f ‚â´ Comma.Hom.hom g) := by
  unfold homEquiv
  simp
  erw [pushforward.homEquiv_symm_comp, pullback.homEquiv_symm_comp]
  rfl

lemma homEquiv_comp_symm {X X' : Over S''} {Y : P.Over ‚ä§ S'}
    (f : (leftAdjoint i q).obj X' ‚ü∂ Y.toComma) (g : X ‚ü∂ X') :
    g ‚â´ (homEquiv i q).symm f =
    (homEquiv i q).symm ((leftAdjoint i q).map g ‚â´ f) := by
  unfold homEquiv
  simp
  erw [pushforward.homEquiv_comp_symm, pullback.homEquiv_comp_symm]
  rfl

def counit :
    partialRightAdjoint i q ‚ãô Over.forget P ‚ä§ S'' ‚ãô leftAdjoint i q ‚ü∂ Over.forget P ‚ä§ S' where
  app _ := homEquiv i q (ùüô _)
  naturality X Y f := by
    apply (homEquiv i q).symm.injective
    conv => left; erw [‚Üê homEquiv_comp_symm]
    conv => right; erw [‚Üê homEquiv_symm_comp]
    simp

end PolynomialPartialAdjunction

variable (P : MorphismProperty C)

namespace Over

@[simps]
def equivalenceOfHasObjects' (R : MorphismProperty C) [R.HasObjects]
    {X : C} (hX : IsTerminal X) : R.Over ‚ä§ X ‚âå Over X where
  functor := MorphismProperty.Over.forget _ _ _
  inverse := Comma.lift (ùü≠ _) (by intro; apply HasObjects.obj_mem _ hX) (by simp) (by simp)
  unitIso := eqToIso rfl
  counitIso := eqToIso rfl
  functor_unitIso_comp := by simp

@[simp]
def equivalenceOfHasObjects (R : MorphismProperty C) [R.HasObjects]
    {X : C} (hX : IsTerminal X) : R.Over ‚ä§ X ‚âå C :=
  (equivalenceOfHasObjects' R hX).trans (Over.equivalenceOfIsTerminal hX)

variable {P : MorphismProperty C} {E B : C}

@[simps]
def ofMorphismProperty (p : E ‚ü∂(P) B) : P.Over ‚ä§ B where
  left := E
  right := ‚ü®‚ü®‚ü©‚ü©
  hom := p.1
  prop := p.2

@[simps]
def homMkTop {p q : P.Over ‚ä§ B} (left : p.left ‚ü∂ q.left) (hleft : left ‚â´ q.hom = p.hom) :
    p ‚ü∂ q where
  left := left
  right := eqToHom (by simp)
  w := by simp [hleft]
  prop_hom_left := trivial
  prop_hom_right := trivial

/--
Convert an object `p` in `R.Over ‚ä§ B` to a morphism in `R.Over ‚ä§ O` by composing with `o`.
     p
 E -----> B
  \      /
   \    /o
    \  /
     VV
     O
-/
@[simp]
def homOfMorphismProperty [P.IsStableUnderComposition] {O} (p : P.Over ‚ä§ B) (o : B ‚ü∂(P) O) :
    (map ‚ä§ o.2).obj p ‚ü∂ Over.ofMorphismProperty o :=
  Over.homMk p.hom (by simp)

end Over

end MorphismProperty

open MorphismProperty.Over

/-- `P : MvPoly R H I O` is a multivariate polynomial functor consisting of the following maps
         p
      E ---> B
  i ‚Üô         ‚Üò o
  I               O

We can lazily read this as `‚àë b : B, X ^ (E b)`,
for some `X` in the (`P`-restricted) slice over `I`.

In full detail:
Viewing such an `X` as a series of variables `X_k` indexed by `k ‚àà I`,
and `B` as a family of types `B_k` indexed by `j ‚àà O`
this can be further viewed as `O`-many `I`-ary polynomials `‚àë b : B_j, X_(i b) ^ (E b)`

To explain the need for two morphism properties,
consider the following two use-cases:
1. `R = ‚ä§` is all maps and the category has all pullbacks.
  `H` is the class of exponentiable maps - it follows from all maps having pullbacks that `H`
  also has pullbacks.
2. `R = H` is a œÄ-clan, [see Joyal, def 2.4.1](https://arxiv.org/pdf/1710.10238).

This will typically be used with the following instances

- For pullback of `R`-maps along `i`, `p` and `o` we need
  `[R.IsStableUnderBaseChange] [R.HasPullbacks]`
- For the left adjoint to pullback for `o` we need `[R.IsStableUnderComposition]`
- For pushforward of `R`-maps along `p` we need
  `[R.IsStableUnderPushforward H] [R.HasPushforwards H]`
- For pushforward of `R`-maps along `p` we also assume `[H.HasPullbacks]`.
  This is useful - it makes the `R`-restricted pushforward of `R`-maps along `p`
  a partial left adjoint to *global* pullback along `p`,
  ```
        pushforward p
   R.Over E -----> R.Over B
      |              |
      |       ‚ä•      |
      |              |
      V              V
     C/E <--------- C/B
         pullback p
  ```
  which is strictly stronger than just having a left adjoint to `R`-restricted pullback
  `(pullback : R.Over B ‚•§ R.Over E) ‚ä£ (pushforward : R.Over E ‚•§ R.Over B)`.
-/
structure MvPoly (R : MorphismProperty C) (H : MorphismProperty C) (I O : C) where
  (E B : C)
  (i : E ‚ü∂(R) I)
  (p : E ‚ü∂(H) B)
  (o : B ‚ü∂(R) O)

namespace MvPoly

instance : (‚ä§ : MorphismProperty C).HasOfPostcompProperty ‚ä§ where
  of_postcomp := by simp

variable {R : MorphismProperty C} {H : MorphismProperty C}

instance {B O : C} (i : B ‚ü∂(R) O) [R.HasPullbacks] [R.IsStableUnderBaseChange]
    [R.IsStableUnderComposition] : (pullback R ‚ä§ i.1).IsRightAdjoint :=
  (mapPullbackAdj R ‚ä§ i.1 i.2 ‚ü®‚ü©).isRightAdjoint

variable {I O : C} (P : MvPoly R H I O) [R.HasPullbacks] [R.IsStableUnderBaseChange]
    [R.IsStableUnderComposition] [H.HasPullbacks] [R.HasPushforwards H]
    [R.IsStableUnderPushforward H]

def functor : R.Over ‚ä§ I ‚•§ R.Over ‚ä§ O :=
  pullback R ‚ä§ P.i.1 ‚ãô MorphismProperty.pushforward R P.p ‚ãô map ‚ä§ P.o.2

/-- The action of a univariate polynomial on objects. -/
def apply (P : MvPoly R H I O) : R.Over ‚ä§ I ‚Üí R.Over ‚ä§ O := (functor P).obj

@[inherit_doc]
infix:90 " @ " => apply

open PolynomialPartialAdjunction

/-- (Ignoring the indexing from `i` and `o`)
This is the first projection morphism from `P @ X = ‚àë b : B, X ^ (E b)` to `B`,
as an object in the `P`-restricted slice over `B`. -/
abbrev fstProj (P : MvPoly R H I O) (X : R.Over ‚ä§ I) : R.Over ‚ä§ P.B :=
  (partialRightAdjoint P.i.1 P.p).obj X

@[reassoc (attr := simp)]
lemma map_fstProj (P : MvPoly R H I O) {X Y : R.Over ‚ä§ I} (f : X ‚ü∂ Y) :
    ((partialRightAdjoint P.i.1 P.p).map f).left ‚â´ (fstProj P Y).hom = (fstProj P X).hom := by
  simp

/-- The counit of the adjunction `pullback p ‚ãô map i ‚ä£ pullback i ‚ãô pushforward p` evaluated at `X`.
Ignoring the indexing from `i` and `o`,
this can be viewed as the second projection morphism from `P @ X = ‚àë b : B, X ^ (E b)`
to `X^ (E b)`.
-/
def sndProj (P : MvPoly R H I O) (X : R.Over ‚ä§ I) :
    (leftAdjoint P.i.1 P.p).obj (fstProj P X).toComma ‚ü∂ X.toComma :=
  (counit P.i.1 P.p).app X

namespace Equiv

variable {P : MvPoly R H I O} {Œì : Over O} {X : R.Over ‚ä§ I}

def fst (pair : Œì ‚ü∂ (P @ X).toComma) : Over P.B := Over.mk (pair.left ‚â´ (fstProj P X).hom)

abbrev sndDom (pair : Œì ‚ü∂ (P @ X).toComma) : Over I := (leftAdjoint P.i.1 P.p).obj (fst pair)

def snd (pair : Œì ‚ü∂ (P @ X).toComma) : sndDom pair ‚ü∂ X.toComma :=
  homEquiv P.i.1 P.p (Over.homMk (pair.left))

lemma snd_eq (pair : Œì ‚ü∂ (P @ X).toComma) : snd pair =
    (leftAdjoint P.i.1 P.p).map (Over.homMk (pair.left)) ‚â´ sndProj P X := by
  erw [Equiv.apply_eq_iff_eq_symm_apply, ‚Üê homEquiv_comp_symm]
  simp [sndProj, counit]

def mk (f : Over P.B) (hf : Œì = (Over.map P.o.1).obj f)
    (s : (leftAdjoint P.i.1 P.p).obj f ‚ü∂ X.toComma) :
    Œì ‚ü∂ (P @ X).toComma :=
  eqToHom hf ‚â´ (Over.map P.o.fst).map ((homEquiv P.i.1 P.p).symm s)

@[simp]
lemma fst_mk (f : Over P.B) (hf : Œì = (Over.map P.o.1).obj f)
    (s : (leftAdjoint P.i.1 P.p).obj f ‚ü∂ X.toComma) : fst (mk f hf s) = f := by
  subst hf; simp [fst, mk]; rfl

lemma snd_mk (f : Over P.B) (hf : Œì = (Over.map P.o.1).obj f)
    (s : (leftAdjoint P.i.1 P.p).obj f ‚ü∂ X.toComma) : snd (mk f hf s) =
    eqToHom (by simp) ‚â´ s := calc snd (mk f hf s)
  _ = (leftAdjoint P.i.1 P.p).map (eqToHom (fst_mk f hf s)) ‚â´ s := by
    erw [Equiv.apply_eq_iff_eq_symm_apply, ‚Üê homEquiv_comp_symm]
    ext
    simp [mk]
  _ = eqToHom _ ‚â´ s := by
    simp only [eqToHom_map]

@[simp]
lemma map_fst (pair : Œì ‚ü∂ (P @ X).toComma) : (Over.map P.o.fst).obj (fst pair) = Œì := by
  have := pair.w
  simp only [Functor.id_obj, Functor.const_obj_obj, Functor.id_map,
    CostructuredArrow.right_eq_id, Functor.const_obj_map, comp_id] at this
  simp [Over.map, Comma.mapRight, fst]
  congr

@[simp]
lemma eta (pair : Œì ‚ü∂ (P @ X).toComma) : mk (fst pair) (by simp) (snd pair) = pair := by
  ext
  simp [mk, snd]

end Equiv

instance (P : MvPoly R H I O) : Limits.PreservesLimitsOfShape WalkingCospan
    (MorphismProperty.Over.map ‚ä§ P.o.2) := by sorry

instance (P : MvPoly R H I O) :
    Limits.PreservesLimitsOfShape WalkingCospan (MvPoly.functor P) := by
  dsimp [functor]
  have : (MorphismProperty.Over.pullback R ‚ä§ P.i.1).IsRightAdjoint :=
    Adjunction.isRightAdjoint (MorphismProperty.Over.mapPullbackAdj R ‚ä§ P.i.1 P.i.2 trivial)
  infer_instance

end MvPoly

/-- `P : UvPoly R E B` is the type of signatures for polynomial functors
         p
      E ---> B

We read this as `‚àë b : B, X ^ (E b)`,
for some `R`-object `X` (meaning the unique map to the terminal object is in `R`).

This notion of polynomial makes sense when `R` is a œÄ-clan,
[see Joyal, def 2.4.1](https://arxiv.org/pdf/1710.10238).
Therefore it will typically be used with the following instances

- For pullback of `R`-maps along `p` we need
  `[R.IsStableUnderBaseChange] [R.HasPullbacks]`
- For the left adjoint to pullback along `B`, we assume `[R.IsStableUnderComposition]`
  and `[R.HasObjects]`, meaning the unique map `B ‚ü∂ ‚ä§_ C` is in `R`.
  For this, we will also assume `[HasTerminal C]`.
- For pushforward of `R`-maps along `p` we need
  `[R.IsStableUnderPushforward R] [R.HasPushforwards R]`
- For pushforward of `R`-maps along `p` we also assume `[R.HasPullbacks]`.
  This is useful - it makes the `R`-restricted pushforward of `R`-maps along `p`
  a partial left adjoint to *global* pullback along `p`,
  ```
        pushforward p
   R.Over E -----> R.Over B
      |              |
      |       ‚ä•      |
      |              |
      V              V
     C/E <--------- C/B
         pullback p
  ```
  which is strictly stronger than just having a left adjoint to `R`-restricted pullback
  `(pullback : R.Over B ‚•§ R.Over E) ‚ä£ (pushforward : R.Over E ‚•§ R.Over B)`.
-/
structure UvPoly (R : MorphismProperty C) (E B : C) where
  (p : E ‚ü∂ B)
  (morphismProperty : R p)

namespace UvPoly

section

variable {R : MorphismProperty C} {E B : C}

variable [HasTerminal C]

variable [R.IsStableUnderComposition] [R.HasPullbacks] [R.IsStableUnderBaseChange] [R.HasObjects]
  [R.IsStableUnderPushforward R] [R.HasPushforwards R]

instance (P : UvPoly R E B) {Œì : C} (A : Œì ‚ü∂ B) : HasPullback A P.p := by
  let p : E ‚ü∂(R) B := ‚ü® P.p, P.morphismProperty ‚ü©
  convert_to HasPullback A p.1
  apply MorphismProperty.instHasPullbackFstHomOfHasPullbacks

def object (X : C) : X ‚ü∂(R) ‚ä§_ C :=
  ‚ü®terminal.from X, HasObjects.obj_mem _ terminalIsTerminal‚ü©

@[simp]
abbrev toOverTerminal : C ‚•§ R.Over ‚ä§ (‚ä§_ C) :=
  (equivalenceOfHasObjects R terminalIsTerminal).inverse

@[simp]
abbrev fromOverTerminal : R.Over ‚ä§ (‚ä§_ C) ‚•§ C :=
  (equivalenceOfHasObjects R terminalIsTerminal).functor

@[simps]
def mvPoly (P : UvPoly R E B) : MvPoly R R (‚ä§_ C) (‚ä§_ C) where
  E := E
  B := B
  i := object E
  p := ‚ü®P.p, P.morphismProperty‚ü©
  o := object B

def functor (P : UvPoly R E B) : C ‚•§ C :=
  toOverTerminal ‚ãô
  MvPoly.functor P.mvPoly ‚ãô
  fromOverTerminal

/-- The action of a univariate polynomial on objects. -/
def apply [HasTerminal C] (P : UvPoly R E B) : C ‚Üí C := P.functor.obj

@[inherit_doc]
infix:90 " @ " => apply

instance [HasTerminal C] (P : UvPoly R E B) :
    Limits.PreservesLimitsOfShape WalkingCospan P.functor := by
  unfold functor
  infer_instance

variable (B)

/-- The identity polynomial functor in single variable. -/
@[simps!]
def id (R : MorphismProperty C) [R.ContainsIdentities] (B) : UvPoly R B B := ‚ü®ùüô B, R.id_mem _ ‚ü©

@[simps!]
def vcomp [R.IsStableUnderComposition] {A B C} (P : UvPoly R A B) (Q : UvPoly R B C) :
    UvPoly R A C :=
  ‚ü® P.p ‚â´ Q.p, R.comp_mem _ _ P.morphismProperty Q.morphismProperty ‚ü©

variable {B}

/-- The fstProjection morphism from `‚àë b : B, X ^ (E b)` to `B` again. -/
def fstProj (P : UvPoly R E B) (X : C) : P @ X ‚ü∂ B :=
  (P.mvPoly.fstProj (toOverTerminal.obj X)).hom

@[reassoc (attr := simp)]
lemma map_fstProj (P : UvPoly R E B) {X Y : C} (f : X ‚ü∂ Y) :
    P.functor.map f ‚â´ fstProj P Y = fstProj P X :=
  P.mvPoly.map_fstProj (toOverTerminal.map f)

/-- The second projection morphism from `P @ X = ‚àë b : B, X ^ (E b)` to `X^ (E b)`. -/
def sndProj (P : UvPoly R E B) (X : C) :
    Limits.pullback (fstProj P X) P.p ‚ü∂ X :=
  (P.mvPoly.sndProj (toOverTerminal.obj X)).left

open TwoSquare

/-- A vertical map `œÅ : P.p.1 ‚ü∂ Q.p.1` of polynomials (i.e. a commutative triangle)
```
    œÅ
E ----> F
 \     /
  \   / \ /
    B
```
induces a natural transformation `Q.functor ‚ü∂ P.functor ` obtained by pasting the following 2-cells
```
              Q.p.1
C --- >  C/F ----> C/B -----> C
|         |          |        |
|   ‚Üô     | œÅ*  ‚âÖ    |   =    |
|         v          v        |
C --- >  C/E ---->  C/B ----> C
              P.p.1
```
-/
def verticalNatTrans {F : C} (P : UvPoly R E B) (Q : UvPoly R F B) (œÅ : E ‚ü∂ F)
    (h : P.p = œÅ ‚â´ Q.p) : Q.functor ‚ü∂ P.functor := sorry --by
  -- have sq : CommSq œÅ P.p.1 Q.p.1 (ùüô _) := by simp [h]
  -- let cellLeft := (Over.starPullbackIsoStar œÅ).hom
  -- let cellMid := (pushforwardPullbackTwoSquare œÅ P.p Q.p (ùüô _) sq)
  -- let cellLeftMidPasted := TwoSquare.whiskerRight (cellLeft ‚â´‚Çï cellMid) (Over.pullbackId).inv
  -- simpa using (cellLeftMidPasted ‚â´‚Çï (vId (forget B)))

/-- A cartesian map of polynomials
```
           P.p
      E -------->  B
      |            |
   œÜ  |            | Œ¥
      v            v
      F -------->  D
           Q.p
```
induces a natural transformation between their associated functors obtained by pasting the following
2-cells
```
              Q.p
C --- >  C/F ----> C/D -----> C
|         |          |        |
|   ‚Üó     | œÜ*  ‚âÖ    | Œ¥* ‚Üó   |
|         v          v        |
C --- >  C/E ---->  C/B ----> C
              P.p
```
-/
def cartesianNatTrans {D F : C} (P : UvPoly R E B) (Q : UvPoly R F D)
    (Œ¥ : B ‚ü∂ D) (œÜ : E ‚ü∂ F) (pb : IsPullback P.p œÜ Œ¥ Q.p) : P.functor ‚ü∂ Q.functor :=
  sorry
  -- let cellLeft : TwoSquare (ùü≠ C) (Over.star F) (Over.star E) (pullback œÜ) :=
  --   (Over.starPullbackIsoStar œÜ).inv
  -- let cellMid :  TwoSquare (pullback œÜ) (pushforward Q.p) (pushforward P.p) (pullback Œ¥) :=
  --   (pushforwardPullbackIsoSquare pb.flip).inv
  -- let cellRight : TwoSquare (pullback Œ¥) (forget D) (forget B) (ùü≠ C) :=
  --   pullbackForgetTwoSquare Œ¥
  -- let := cellLeft ‚â´·µ• cellMid ‚â´·µ• cellRight
  -- this

theorem isCartesian_cartesianNatTrans {D F : C} (P : UvPoly R E B) (Q : UvPoly R F D)
    (Œ¥ : B ‚ü∂ D) (œÜ : E ‚ü∂ F) (pb : IsPullback P.p œÜ Œ¥ Q.p) :
    (cartesianNatTrans P Q Œ¥ œÜ pb).IsCartesian := by
  sorry
  -- simp [cartesianNatTrans]
  -- infer_instance

  -- (isCartesian_of_isIso _).vComp <|
  -- (isCartesian_of_isIso _).vComp <|
  -- isCartesian_pullbackForgetTwoSquare _

/-- A morphism from a polynomial `P` to a polynomial `Q` is a pair of morphisms `e : E ‚ü∂ E'`
and `b : B ‚ü∂ B'` such that the diagram
```
      E -- P.p ->  B
      ^            |
   œÅ  |            |
      |     œà      |
      Pb --------> B
      |            |
   œÜ  |            | Œ¥
      v            v
      F -- Q.p ->  D
```
is a pullback square. -/
structure Hom {F D : C} (P : UvPoly R E B) (Q : UvPoly R F D) where
  Pb : C
  Œ¥ : B ‚ü∂ D
  œÜ : Pb ‚ü∂ F
  œà : Pb ‚ü∂ B
  œÅ : Pb ‚ü∂ E
  is_pb : IsPullback œà œÜ Œ¥ Q.p
  w : œÅ ‚â´ P.p = œà

namespace Hom

open IsPullback

/-- The identity morphism in the category of polynomials. -/
def id (P : UvPoly R E B) : Hom P P := ‚ü®E, ùüô B, ùüô _ , P.p , ùüô _, IsPullback.of_id_snd, by simp‚ü©

-- def vertCartExchange

/-- The composition of morphisms in the category of polynomials. -/
def comp {E B F D N M : C} {P : UvPoly R E B} {Q : UvPoly R F D} {R : UvPoly R N M}
    (f : Hom P Q) (g : Hom Q R) : Hom P R := sorry

end Hom

/-- The domain of the composition of two polynomials. See `UvPoly.comp`. -/
def compDom {E B E' B' : C} (P : UvPoly R E B) (P' : UvPoly R E' B') : C :=
  sorry
  -- Limits.pullback P'.p (fan P A).snd

@[simps!]
def comp {E B E' B' : C} (P : UvPoly R E B) (P' : UvPoly R E' B') :
    UvPoly R (compDom P P') (P @ B') where
  p := sorry -- pullback.snd Q.p (fan P A).snd ‚â´ pullback.fst (fan P A).fst P.p
  morphismProperty := sorry


namespace Equiv

variable {P : UvPoly R E B} {Œì X Y : C}

/-- Convert the morphism `pair` into a morphism in the over category `Over (‚ä§_ C)` -/
@[simp]
abbrev fstAux (pair : Œì ‚ü∂ P @ X) : Over.mk (terminal.from Œì) ‚ü∂
    ((toOverTerminal ‚ãô MvPoly.functor P.mvPoly).obj X).toComma := Over.homMk pair

def fst (pair : Œì ‚ü∂ P @ X) : Œì ‚ü∂ B :=
  (MvPoly.Equiv.fst (fstAux pair)).hom

lemma fst_eq (pair : Œì ‚ü∂ P @ X) : fst pair = pair ‚â´ P.fstProj X := by
  aesop_cat

def snd (pair : Œì ‚ü∂ P @ X) : Limits.pullback (fst pair) P.p ‚ü∂ X :=
  (MvPoly.Equiv.snd (fstAux pair)).left

lemma snd_eq (pair : Œì ‚ü∂ P @ X) : snd pair =
    Limits.pullback.map (fst pair) P.p (P.fstProj X) P.p pair (ùüô E) (ùüô B) (by simp [fst_eq])
    (by simp) ‚â´ sndProj P X := by
  simpa [Limits.pullback.map] using congrArg CommaMorphism.left (MvPoly.Equiv.snd_eq (fstAux pair))

def snd' (pair : Œì ‚ü∂ P @ X) {pb f g} (H : IsPullback (P := pb) f g (fst pair) P.p) : pb ‚ü∂ X :=
  H.isoPullback.hom ‚â´ snd pair

theorem snd_eq_snd' (pair : Œì ‚ü∂ P @ X) :
    snd pair = snd' pair (.of_hasPullback ..) := by simp [snd']; sorry
    -- simp lemma in HoTTLean ForMathlib

/-- Convert the morphism `x` into a morphism in the over category `Over (‚ä§_ C)` -/
@[simp]
abbrev mkAux (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    (PolynomialPartialAdjunction.leftAdjoint P.mvPoly.i.fst P.mvPoly.p).obj (Over.mk b) ‚ü∂
    ((toOverTerminal (R := R)).obj X).toComma :=
    -- Over.mk (terminal.from (pullback b P.p.1)) ‚ü∂ ((toOverTerminal (R := R)).obj X).toComma :=
  Over.homMk x

def mk (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) : Œì ‚ü∂ P @ X :=
  (MvPoly.Equiv.mk (P := P.mvPoly) (Œì := Over.mk (terminal.from Œì))
    (Over.mk b) (by congr; apply terminal.hom_ext) (mkAux b x)).left

def mk' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X) : Œì ‚ü∂ P @ X :=
  mk b (H.isoPullback.inv ‚â´ x)

theorem mk_eq_mk' (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    mk b x = mk' b (.of_hasPullback ..) x := by simp [mk']; sorry

@[simp]
lemma fst_mk (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    fst (mk b x) = b := by
  simp only [fst, mk, Over.homMk_eta]
  rw! (castMode := .all) [MvPoly.Equiv.fst_mk]
  simp [‚Üê heq_eq_eq]; rfl

@[simp]
lemma fst_mk' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X) :
    fst (mk' b H x) = b := by
  simp [mk']

@[simp]
lemma mk'_comp_fstProj (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X) :
    mk' b H x ‚â´ P.fstProj X = b := by
  simp [‚Üê fst_eq]

theorem fst_comp_left (pair : Œì ‚ü∂ P @ X) {Œî} (f : Œî ‚ü∂ Œì) :
    fst (f ‚â´ pair) = f ‚â´ fst pair := by simp [fst_eq]

theorem fst_comp_right (pair : Œì ‚ü∂ P @ X) (f : X ‚ü∂ Y) :
    fst (pair ‚â´ P.functor.map f) = fst pair := by
  simp [fst_eq]

lemma snd'_eq (pair : Œì ‚ü∂ P @ X) {pb f g} (H : IsPullback (P := pb) f g (fst pair) P.p) :
    snd' pair H = pullback.lift (f ‚â´ pair) g (by simpa using H.w) ‚â´ sndProj P X := by
  rw [snd', snd_eq, ‚Üê Category.assoc]
  congr 1
  ext <;> simp

/-- Switch the selected pullback `pb` used in `UvPoly.Equiv.snd'` with a different pullback `pb'`. -/
lemma snd'_eq_snd' (pair : Œì ‚ü∂ P @ X) {pb f g} (H : IsPullback (P := pb) f g (fst pair) P.p)
    {pb' f' g'} (H' : IsPullback (P := pb') f' g' (fst pair) P.p) :
    snd' pair H = (H.isoIsPullback _ _ H').hom ‚â´ snd' pair H' := by
  simp [snd'_eq, ‚Üê Category.assoc]
  congr 2
  ext <;> simp

@[simp]
lemma snd'_mk' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X) :
    snd' (mk' b H x) (by rwa [fst_mk']) = x := by
  sorry
  -- have : comparison (c := fan P X) (mk' P X b H x) ‚â´ _ =
  --     (pullback.congrHom (f‚ÇÅ := mk' P X b H x ‚â´ _) ..).hom ‚â´ _ :=
  --   partialProd.lift_snd ‚ü®fan P X, isLimitFan P X‚ü© b (H.isoPullback.inv ‚â´ x)
  -- have H' : IsPullback (P := R) f g (mk' P X b H x ‚â´ (fan P X).fst) P.p.1 := by simpa
  -- convert congr(H'.isoPullback.hom ‚â´ $(this)) using 1
  -- ¬∑ simp [partialProd.snd, partialProd.cone, snd'_eq]
  --   simp only [‚Üê Category.assoc]; congr! 2
  --   simp [comparison]; ext <;> simp
  -- ¬∑ slice_rhs 1 0 => skip
  --   refine .symm <| .trans ?_ (Category.id_comp _); congr! 1
  --   rw [Iso.comp_inv_eq_id]; ext <;> simp

lemma snd_mk_heq (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    snd (mk b x) ‚âç x := by
  sorry
  -- have h := mk_eq_mk' P X b x
  -- set t := mk' P ..
  -- have : snd' P X t _ = x := snd'_mk' ..
  -- refine .trans ?_ this.heq
  -- rw [snd_eq_snd']; congr! 2 <;> simp

lemma snd_mk (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    snd (mk b x) = eqToHom (by simp) ‚â´ x := by
  apply eq_of_heq; rw [heq_eqToHom_comp_iff]; apply snd_mk_heq

theorem snd'_comp_left (pair : Œì ‚ü∂ P @ X)
    {pb f g} (H : IsPullback (P := pb) f g (fst pair) P.p)
    {Œî} (œÉ : Œî ‚ü∂ Œì)
    {pb' f' g'} (H' : IsPullback (P := pb') f' g' (œÉ ‚â´ fst pair) P.p) :
    snd' (œÉ ‚â´ pair) (by convert H'; rw [fst_comp_left]) =
    H.lift (f' ‚â´ œÉ) g' (by simp [H'.w]) ‚â´ snd' pair H := by
  simp only [snd'_eq, ‚Üê Category.assoc]
  congr 2
  ext
  ¬∑ simp
  ¬∑ simp

theorem snd'_comp_right (pair : Œì ‚ü∂ P @ X) (f : X ‚ü∂ Y)
    {pb f1 f2} (H : IsPullback (P := pb) f1 f2 (fst pair) P.p) :
    snd' (pair ‚â´ P.functor.map f) (by rwa [fst_comp_right]) =
    snd' pair H ‚â´ f := by
  sorry
  -- simp [snd'_eq, fan_snd, Œµ]
  -- have := congr($((ExponentiableMorphism.ev P.p.1).naturality ((Over.star E).map f)).left ‚â´ prod.snd)
  -- dsimp at this; simp at this
  -- rw [‚Üê this]; clear this
  -- simp only [‚Üê Category.assoc]; congr! 2
  -- ext <;> simp
  -- ¬∑ slice_rhs 2 3 => apply pullback.lift_fst
  --   slice_rhs 1 2 => apply pullback.lift_fst
  --   simp; rfl
  -- ¬∑ slice_rhs 2 3 => apply pullback.lift_snd
  --   symm; apply pullback.lift_snd

theorem snd_comp_right (pair : Œì ‚ü∂ P @ X) (f : X ‚ü∂ Y) : snd (pair ‚â´ P.functor.map f) =
    eqToHom (by congr 1; apply fst_comp_right) ‚â´ snd pair ‚â´ f := by
  -- rw [snd_eq_snd', snd'_comp_right, snd', Category.assoc, ‚Üê eqToIso.hom]; congr! 2
  -- exact IsPullback.isoPullback_eq_eqToIso_left (fst_comp_right _ _ _ f pair) P.p.1
  sorry

lemma ext' {pair‚ÇÅ pair‚ÇÇ : Œì ‚ü∂ P @ X}
    {pb f g} (H : IsPullback (P := pb) f g (fst pair‚ÇÅ) P.p)
    (h1 : fst pair‚ÇÅ = fst pair‚ÇÇ)
    (h2 : snd' pair‚ÇÅ H = snd' pair‚ÇÇ (by rwa [h1] at H)) :
    pair‚ÇÅ = pair‚ÇÇ := by
  -- simp [fst_eq] at h1 H
  -- apply partialProd.hom_ext ‚ü®fan P X, isLimitFan P X‚ü© h1
  -- refine (cancel_epi H.isoPullback.hom).1 ?_
  -- convert h2 using 1 <;> (
  --   simp [snd'_eq, comparison_pullback.map, partialProd.snd, partialProd.cone]
  --   simp only [‚Üê Category.assoc]; congr! 2
  --   ext <;> simp)
  -- ¬∑ slice_lhs 2 3 => apply pullback.lift_fst
  --   slice_lhs 1 2 => apply H.isoPullback_hom_fst
  --   simp
  -- ¬∑ slice_lhs 2 3 => apply pullback.lift_snd
  --   slice_lhs 1 2 => apply H.isoPullback_hom_snd
  --   simp
  sorry

/-- Switch the selected pullback `pb` used in `UvPoly.Equiv.mk'` with a different pullback `pb'`. -/
theorem mk'_eq_mk' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X)
    {pb' f' g'} (H' : IsPullback (P := pb') f' g' b P.p) :
    mk' b H x = mk' b H' ((IsPullback.isoIsPullback _ _ H H').inv ‚â´ x) := by
  -- apply ext' P X (R := R) (f := f) (g := g) (by convert H; simp)
  -- ¬∑ rw [snd'_eq_snd' P X (mk' P X b H' ((IsPullback.isoIsPullback _ _ H H').inv ‚â´ x))
  --     (by convert H; simp) (by convert H'; simp)]
  --   simp [snd'_mk']
  -- ¬∑ simp
  sorry

@[simp]
lemma eta' (pair : Œì ‚ü∂ P @ X)
    {pb f1 f2} (H : IsPullback (P := pb) f1 f2 (fst pair) P.p) :
    mk' (fst pair) H (snd' pair H) = pair :=
  .symm <| ext' H (by simp) (by simp)

@[simp]
lemma eta (pair : Œì ‚ü∂ P @ X) :
    mk (fst pair) (snd pair) = pair := by
  simp [mk_eq_mk', snd_eq_snd']

lemma mk'_comp_right (b : Œì ‚ü∂ B) {pb f1 f2} (H : IsPullback (P := pb) f1 f2 b P.p) (x : pb ‚ü∂ X)
    (f : X ‚ü∂ Y) : mk' b H x ‚â´ P.functor.map f = mk' b H (x ‚â´ f) := by
  -- refine .symm <| ext' _ _ (by rwa [fst_mk']) (by simp [fst_comp_right]) ?_
  -- rw [snd'_comp_right (H := by rwa [fst_mk'])]; simp
  sorry

lemma mk_comp_right (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) (f : X ‚ü∂ Y) :
    mk b x ‚â´ P.functor.map f = mk b (x ‚â´ f) := by
  simp [mk_eq_mk', mk'_comp_right]

theorem mk'_comp_left {Œî}
    (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback f g b P.p) (x : pb ‚ü∂ X) (œÉ : Œî ‚ü∂ Œì)
    (œÉb) (eq : œÉ ‚â´ b = œÉb)
    {pb' f' g'} (H' : IsPullback (P := pb') f' g' œÉb P.p) :
    œÉ ‚â´ UvPoly.Equiv.mk' b H x = UvPoly.Equiv.mk' œÉb H'
    (H.lift (f' ‚â´ œÉ) g' (by simp [eq, H'.w]) ‚â´ x) := by
  apply ext' (f := f') (g := g') (H := by convert H'; simp [eq, fst_eq])
  ¬∑ rw [snd'_comp_left (H := by convert H; rw [fst_mk']) (H' := by convert H'; rw [‚Üê eq, fst_mk'])]
    simp
  ¬∑ simp [eq, fst_comp_left]

theorem mk_comp_left {Œî} (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) (œÉ: Œî ‚ü∂ Œì) :
    œÉ ‚â´ UvPoly.Equiv.mk b x =
    UvPoly.Equiv.mk (œÉ ‚â´ b)
      (pullback.map _ _ _ _ œÉ (ùüô _) (ùüô _) (by simp) (by simp) ‚â´ x) := by
  simp only [mk_eq_mk']
  rw [mk'_comp_left (H := .of_hasPullback _ _) (H' := .of_hasPullback _ _) (eq := rfl)]
  congr 2; ext <;> simp

-- lemma mk'_comp_cartesianNatTrans_app {E' B' Œì X : C} {P' : UvPoly R E' B'}
--     (y : Œì ‚ü∂ B) (pb f g) (H : IsPullback (P := pb) f g y P.p.1)
--     (x : pb ‚ü∂ X) (e : E ‚ü∂ E') (b : B ‚ü∂ B')
--     (hp : IsPullback P.p.1 e b P'.p.1) :
--     Equiv.mk' y H x ‚â´ (P.cartesianNatTrans P' b e hp).app X =
--     Equiv.mk' P' X (y ‚â´ b) (H.paste_vert hp) x := by
--   have : fst P' X (Equiv.mk' P X y H x ‚â´ (P.cartesianNatTrans P' b e hp).app X) = y ‚â´ b := by
--     rw [fst_eq, Category.assoc, cartesianNatTrans_fstProj, ‚Üê Category.assoc, mk'_comp_fstProj]
--   refine ext' _ _ (this ‚ñ∏ H.paste_vert hp) (by simpa) ?_
--   simp; rw [snd'_eq]
--   have := snd'_mk' P X y H x
--   rw [snd'_eq, ‚Üê fan_snd_map' _ _ X hp] at this
--   refine .trans ?_ this
--   simp only [‚Üê Category.assoc]; congr 1; ext <;> simp

end Equiv

instance preservesPullbacks (P : UvPoly R E B) {Pb X Y Z : C} (fst : Pb ‚ü∂ X) (snd : Pb ‚ü∂ Y)
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (h: IsPullback fst snd f g) :
    IsPullback (P.functor.map fst) (P.functor.map snd) (P.functor.map f) (P.functor.map g) :=
  P.functor.map_isPullback h
