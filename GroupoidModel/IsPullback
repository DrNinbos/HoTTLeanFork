import GroupoidModel.ForMathlib
import Mathlib.CategoryTheory.Widesubcategory

universe v u v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ v‚ÇÉ u‚ÇÉ

/-!
## Strict (meta-theoretic) 1-pullbacks of categories
* Due to universe level complications, it is convenient to have
  a version of pullbacks of categories that is agnostic to universe levels,
  providing a universal property for cones with apex of any universe size.
  This is essentially the same as asking for a pullback in `Cat.{max ‚ãØ, max ‚ãØ}`,
  (where all the categories are adjusted by `ULift`).
* However, Lean cannot express quantification of universe variables,
  we state `CategoryTheory.Functor.Pullback` via being isomorphic
  to a chosen pullback
  `CategoryTheory.Functor.Pullback.Chosen`.

## Main definitions
* `CategoryTheory.Functor.Pullback.Chosen` a construction of the
  strict 1-pullback of categories as a (non-full)
  subcategory of the product.
* `CategoryTheory.Functor.Pullback` being a pullback of a functor
  is to be isomorphic (functors to and from that compose to identity)
  to the chosen pullback `CategoryTheory.Functor.Pullback.Chosen`.
* Pullback pasting, in `pasteHoriz` and `ofRight` and `ofRight'`.
-/

namespace CategoryTheory.Functor

section

variable {Egypt : Type u‚ÇÇ} [Category.{v‚ÇÇ} Egypt]
  {Chad : Type u‚ÇÉ} [Category.{v‚ÇÉ} Chad]
  {Sudan : Type*} [Category Sudan]
  (east : Egypt ‚•§ Sudan) (south : Chad ‚•§ Sudan)

namespace Pullback

/--
  The chosen pullback category `Chosen` is a wide subcategory
  of this intermediate category `ChosenObjects`,
  which itself is a full subcategory of the product `Egypt √ó Chad`.
  Objects in this full subcategory are those whose two components are
  sent to equal objects in the base category `Sudan`.
-/
def ChosenObjects := FullSubcategory (
  fun p : Egypt √ó Chad => east.obj p.1 = south.obj p.2 )

namespace ChosenObjects

instance : Category (ChosenObjects east south) :=
  inferInstanceAs (Category (FullSubcategory _))

end ChosenObjects

/--
  Morphisms in `Chosen` are morphisms from `ChosenObjects`
  whose two components are sent to equal maps in the base category `Sudan`.
-/
def morphismProperty : MorphismProperty (ChosenObjects east south) :=
  fun {x y} f => east.map f.1
    = eqToHom x.property ‚â´ south.map f.2 ‚â´ eqToHom y.property.symm

instance : MorphismProperty.IsMultiplicative (morphismProperty east south) where
  id_mem x := by
    simp [morphismProperty, ChosenObjects, FullSubcategory.id_def]
  comp_mem f g hf hg := by
    simp only [morphismProperty, ChosenObjects,
      FullSubcategory.comp_def, comp_eqToHom_iff] at *
    simp [hg, hf]

/--
  The chosen pullback category `Chosen` is a wide subcategory
  of `ChosenObjects`,
  consisting of pairs of maps from `Egypt` and `Chad`
  that are equal in the base category `Sudan`.
-/
def Chosen := WideSubcategory (morphismProperty east south)

instance : Category (Chosen east south) :=
  inferInstanceAs (Category (WideSubcategory _))

variable (Libya : Type*) [Category Libya]

/-
       north
  Libya ----> Egypt
    |          |
  west         |east
    |          |
    V          V
  Chad ----> Sudan
       south
-/

/--
Pullback cones are pairs of functors that form a strictly commutative
square
-/
structure Cone where
  (north : Libya ‚•§ Egypt)
  (west : Libya ‚•§ Chad)
  (comm_sq : north ‚ãô east = west ‚ãô south)

variable {east} {south}

/--
Precomposing a cone with a functor into the apex produces another cone.
-/
@[simps] def Cone.pre {C : Type*} [Category C] (cone : Cone east south C)
    {D : Type*} [Category D] (F : D ‚•§ C) : Cone east south D where
  north := F ‚ãô cone.north
  west := F ‚ãô cone.west
  comm_sq := by rw [Functor.assoc, Functor.assoc, cone.comm_sq]

namespace Chosen

variable {C : Type u} [Category.{v} C]

def north : Chosen east south ‚•§ Egypt :=
  wideSubcategoryInclusion _ ‚ãô fullSubcategoryInclusion _ ‚ãô Prod.fst _ _

def west : Chosen east south ‚•§ Chad :=
  wideSubcategoryInclusion _ ‚ãô fullSubcategoryInclusion _ ‚ãô Prod.snd _ _

theorem comm_sq : @north _ _ _ _ _ _ east south ‚ãô east = west ‚ãô south := by
  fapply Functor.ext
  ¬∑ intro x
    exact x.obj.property
  ¬∑ intro x y f
    exact f.property

variable (east) (south) in
/--
The chosen pullback `Chosen` forms a pullback cone.
-/
@[simps] def cone : Cone east south (Chosen east south) where
  north := north
  west := west
  comm_sq := comm_sq

variable (cone : Cone east south C)

/--
The universal lift of the chosen pullback `Chosen`.
-/
def lift : C ‚•§ Chosen east south where
  obj x := ‚ü® ‚ü® cone.north.obj x , cone.west.obj x ‚ü© , congr_obj cone.comm_sq x ‚ü©
  map f := ‚ü® ‚ü® cone.north.map f , cone.west.map f ‚ü© , congr_hom cone.comm_sq f ‚ü©

/--
The universal lift of the chosen pullback `Chosen` commutes with projections.
-/
theorem fac_left : lift cone ‚ãô north = cone.north :=
  rfl

/--
The universal lift of the chosen pullback `Chosen` commutes with projections.
-/
theorem fac_right : lift cone ‚ãô west = cone.west :=
  rfl

/--
Lifts of the chosen pullback `Chosen` are unique.
-/
theorem hom_ext {l0 l1 : C ‚•§ Chosen east south} (hnorth : l0 ‚ãô north = l1 ‚ãô north)
   (hwest : l0 ‚ãô west = l1 ‚ãô west) : l0 = l1 := by
  fapply Functor.ext
  ¬∑ intro x
    apply WideSubcategory.ext
    apply FullSubcategory.ext
    apply Prod.ext
    ¬∑ exact congr_obj hnorth x
    ¬∑ exact congr_obj hwest x
  ¬∑ intro x y f
    apply (wideSubcategory.faithful _).map_injective
    apply (FullSubcategory.faithful _).map_injective
    apply prod.hom_ext
    ¬∑ convert congr_hom hnorth f
      simp only [Functor.map_comp, eqToHom_map]
      simp [north]
    ¬∑ convert congr_hom hwest f
      simp only [Functor.map_comp, eqToHom_map]
      simp [west]

end Chosen

end Pullback

open Pullback

/--
A pullback structure on a type `Libya` over a pair of functors
`east` and `south` with the same codomain consists of an isomorphism
with the chosen pullback `CategoryTheory.Functor.Pullback.Chosen east south`.
This is a strict isomorphism in the sense of having functors back and forth
that compose to *equal* the identity,
but since the universe levels are variable these are not the same it does not fit
into mathlib's definition of an isomorphism.
-/
structure Pullback (Libya : Type*) [Category Libya] extends
    Cone east south Libya where
  (toChosen : Libya ‚•§ Chosen east south)
  (fromChosen : Chosen east south ‚•§ Libya)
  (to_from_id : toChosen ‚ãô fromChosen = ùü≠ _)
  (from_to_id : fromChosen ‚ãô toChosen = ùü≠ _)
  (from_north : fromChosen ‚ãô north = Chosen.north)
  (from_west : fromChosen ‚ãô west = Chosen.west)

structure IsPullback {Libya : Type*} [Category Libya] (cone : Cone east south Libya) where
  (toChosen : Libya ‚•§ Chosen east south)
  (fromChosen : Chosen east south ‚•§ Libya)
  (to_from_id : toChosen ‚ãô fromChosen = ùü≠ _)
  (from_to_id : fromChosen ‚ãô toChosen = ùü≠ _)
  (from_north : fromChosen ‚ãô cone.north = Chosen.north)
  (from_west : fromChosen ‚ãô cone.west = Chosen.west)

namespace Pullback

variable {east} {south}

section

variable {Libya : Type*} [Category Libya]

def ofIso (toChosen : Libya ‚•§ Chosen east south) (fromChosen : Chosen east south ‚•§ Libya)
    (htf : toChosen ‚ãô fromChosen = ùü≠ _) (hft: fromChosen ‚ãô toChosen = ùü≠ _) :
    Pullback east south Libya := {
  (Cone.pre (Chosen.cone east south) toChosen) with
  toChosen := toChosen
  fromChosen := fromChosen
  to_from_id := htf
  from_to_id := hft
  from_north := by
    simp [‚Üê Functor.assoc, hft, Functor.id_comp]
  from_west := by
    simp [‚Üê Functor.assoc, hft, Functor.id_comp]
    }

variable (P : Pullback east south Libya)
/--
Commuting conditions between a general pullback `P` and the chosen pullback.
-/
theorem to_north : P.toChosen ‚ãô Chosen.north = P.north := by
  rw [‚Üê P.from_north, ‚Üê Functor.assoc, to_from_id, Functor.id_comp]

/--
Commuting conditions between a general pullback `P` and the chosen pullback.
-/
theorem to_west : P.toChosen ‚ãô Chosen.west = P.west := by
  rw [‚Üê P.from_west, ‚Üê Functor.assoc, to_from_id, Functor.id_comp]

variable {C : Type u} [Category.{v} C] (cone : Cone east south C)

/--
The universal lift of the pullback `P`.
-/
def lift : C ‚•§ Libya := Chosen.lift cone ‚ãô P.fromChosen

/--
Commuting conditions for the universal lift of the pullback `P`.
-/
theorem fac_left : lift P cone ‚ãô P.north = cone.north := by
  simp [lift, Functor.assoc, from_north, Chosen.fac_left]

/--
Commuting conditions for the universal lift of the pullback `P`.
-/
theorem fac_right : lift P cone ‚ãô P.west = cone.west := by
  simp [lift, Functor.assoc, from_west, Chosen.fac_right]

/--
Uniqueness of universal lifts for the pullback `P`.
-/
theorem hom_ext {l0 l1 : C ‚•§ Libya} (hnorth : l0 ‚ãô P.north = l1 ‚ãô P.north)
    (hwest : l0 ‚ãô P.west = l1 ‚ãô P.west) : l0 = l1 :=
  calc l0
    _ = l0 ‚ãô P.toChosen ‚ãô P.fromChosen := by
      rw [to_from_id, Functor.comp_id]
    _ = l1 ‚ãô P.toChosen ‚ãô P.fromChosen := by
      dsimp only [‚Üê Functor.assoc]
      congr 1
      apply Chosen.hom_ext
      ¬∑ simp [Functor.assoc, to_north, hnorth]
      ¬∑ simp [Functor.assoc, to_west, hwest]
    _ = l1 := by rw [to_from_id, Functor.comp_id]

end

-- section
-- variable {Libya : Type*} [Category Libya] (P : Cone east south Libya)
-- variable (L : ‚àÄ {C : Type (max u‚ÇÇ u‚ÇÉ)} [Category.{max v‚ÇÇ v‚ÇÉ} C]
--   (cone : Cone east south C),
--   (lift : C ‚•§ Libya) √ó'
--   (lift ‚ãô P.north = cone.north) ‚àß
--   (lift ‚ãô P.west = cone.west) ‚àß
--   (‚àÄ {l0 l1 : C ‚•§ Libya}, l0 ‚ãô P.north = l1 ‚ãô P.north ‚Üí
--     l0 ‚ãô P.west = l1 ‚ãô P.west ‚Üí l0 = l1))

-- /--
--   To define a pullback structure on a category,
--   rather than showing a category is isomorphic to the chosen pullback,
--   we can instead show its universal property.
--   One should on an ad-hoc basis state and prove a more general universal property
--   (with more general universe levels)
--   and then specialize it to this choice of universe levels.

--   When we *use* the universal property of a pullback,
--   we want to use the more general version `CategoryTheory.Functor.Pullback.lift` etc.
-- -/
-- def ofLift : Pullback east south Libya := {
--   P with
--   toChosen := Chosen.lift P
--   fromChosen := (L (Chosen.cone east south)).0
--   to_from_id := by
--     apply (L (Chosen.cone east south)).1.2.2

--     sorry
--     sorry
--     sorry
--   from_to_id := sorry
-- }


-- end

section
/-
           no           rth
  Algeria -----> Libya ----> Egypt
    |              |          |
  west         sah |          | east
    |              |          |
    V              V          V
  Niger   -----> Chad  ----> Sudan
           so           uth
-/
variable {Libya : Type*} [Category Libya] (P : Cone east south Libya)
variable {Algeria Niger : Type*} [Category Algeria] [Category Niger]
  {no : Algeria ‚•§ Libya} {rth : Libya ‚•§ Egypt}
  {west : Algeria ‚•§ Niger} {sah : Libya ‚•§ Chad} {east : Egypt ‚•§ Sudan}
  {so : Niger ‚•§ Chad} {uth : Chad ‚•§ Sudan}
  (wsah : no ‚ãô sah = west ‚ãô so) (esah : rth ‚ãô east = sah ‚ãô uth)
  (esah_pb : Œ† {C : Type u} [Category.{v} C] (cone : PullbackCone C east uth),
    Pullback (PullbackCone.mk _ _ esah) cone)
  (wsah_pb : Œ† {C : Type u} [Category.{v} C] (cone : PullbackCone C sah so),
    Pullback (PullbackCone.mk _ _ wsah) cone)

variable {C : Type u} [Category.{v} C] (cone : PullbackCone C east (so ‚ãô uth))

@[simps] def pasteHorizEastCone : PullbackCone C east uth where
  north := cone.north
  west := cone.west ‚ãô so
  comm_sq := cone.comm_sq

@[simps] def pasteHorizWestCone : PullbackCone C sah so where
  north := (esah_pb (pasteHorizEastCone cone)).lift
  west := cone.west
  comm_sq := (esah_pb (pasteHorizEastCone cone)).fac_right

/--
Pullback pasting =>.
The outer square is a pullback when the two inner squares
are both pullbacks.
           no           rth
  Algeria -----> Libya ----> Egypt
    |              |          |
  west         sah |          | east
    |              |          |
    V              V          V
  Niger   -----> Chad  ----> Sudan
           so           uth
-/
def pasteHoriz : Pullback (PullbackCone.mk (no ‚ãô rth) west (by
    rw [Functor.assoc, esah, ‚Üê Functor.assoc, wsah, Functor.assoc])) cone where
  lift := (wsah_pb (pasteHorizWestCone esah esah_pb cone)).lift
  fac_left := by
    rw [‚Üê Functor.assoc, (wsah_pb _).fac_left]
    exact (esah_pb _).fac_left
  fac_right := (wsah_pb _).fac_right
  hom_ext hleft hright := by
    apply (wsah_pb (pasteHorizWestCone esah esah_pb cone)).hom_ext
    ¬∑ apply (esah_pb (pasteHorizEastCone cone)).hom_ext
      ¬∑ exact hleft
      ¬∑ simp only [Functor.assoc, wsah]
        simp only [‚Üê Functor.assoc, hright]
    ¬∑ exact hright
end
end Pullback

end
#exit
section
variable {Libya Egypt Chad Sudan : Type*}
  [Category Libya] [Category Egypt] [Category Chad] [Category Sudan]

/-
       north
  Libya ----> Egypt
    |          |
  west         |east
    |          |
    V          V
  Chad ----> Sudan
       south
-/

structure PullbackCone (C : Type*) [Category C] (east : Egypt ‚•§ Sudan) (south : Chad ‚•§ Sudan) where
  (north : C ‚•§ Egypt)
  (west : C ‚•§ Chad)
  (comm_sq : north ‚ãô east = west ‚ãô south)

structure Pullback {east : Egypt ‚•§ Sudan} {south : Chad ‚•§ Sudan}
    (P : PullbackCone Libya east south)
    {C : Type u} [Category.{v} C] (cone : PullbackCone C east south) where
  (lift : C ‚•§ Libya)
  (fac_left : lift ‚ãô P.north = cone.north)
  (fac_right : lift ‚ãô P.west = cone.west)
  (hom_ext {l0 l1 : C ‚•§ Libya} : l0 ‚ãô P.north = l1 ‚ãô P.north ‚Üí
    l0 ‚ãô P.west = l1 ‚ãô P.west ‚Üí l0 = l1)

namespace Pullback


section
/-
           no           rth
  Algeria -----> Libya ----> Egypt
    |              |          |
  west         sah |          | east
    |              |          |
    V              V          V
  Niger   -----> Chad  ----> Sudan
           so           uth
-/
variable {Algeria Niger : Type*} [Category Algeria] [Category Niger]
  {no : Algeria ‚•§ Libya} {rth : Libya ‚•§ Egypt}
  {west : Algeria ‚•§ Niger} {sah : Libya ‚•§ Chad} {east : Egypt ‚•§ Sudan}
  {so : Niger ‚•§ Chad} {uth : Chad ‚•§ Sudan}
  (wsah : no ‚ãô sah = west ‚ãô so) (esah : rth ‚ãô east = sah ‚ãô uth)
  (esah_pb : Œ† {C : Type u} [Category.{v} C] (cone : PullbackCone C east uth),
    Pullback (PullbackCone.mk _ _ esah) cone)
  (outer_pb : Œ† {C : Type u} [Category.{v} C] (cone : PullbackCone C east (so ‚ãô uth)),
    Pullback (PullbackCone.mk (no ‚ãô rth) west (by
      rw [Functor.assoc, esah, ‚Üê Functor.assoc, wsah, Functor.assoc]))
      cone)

variable {C : Type u} [Category.{v} C] (cone : PullbackCone C sah so)

@[simps] def ofRightOuterCone : PullbackCone C east (so ‚ãô uth) where
  north := cone.north ‚ãô rth
  west := cone.west
  comm_sq := by
    rw [Functor.assoc, esah, ‚Üê Functor.assoc, cone.comm_sq, Functor.assoc]

def ofRightRightCone : PullbackCone C east uth where
  north := cone.north ‚ãô rth
  west := cone.west ‚ãô so
  comm_sq := by rw [Functor.assoc, esah, ‚Üê Functor.assoc, cone.comm_sq]

/--
Pullback pasting <=.
The left square is a pullback when the right and outer squares
are both pullbacks.
           no           rth
  Algeria -----> Libya ----> Egypt
    |              |          |
  west         sah |          | east
    |              |          |
    V              V          V
  Niger   -----> Chad  ----> Sudan
           so           uth
-/
def ofRight : Pullback (PullbackCone.mk no west wsah) cone where
  lift := (outer_pb (ofRightOuterCone esah cone)).lift
  fac_left := by
    apply (esah_pb (ofRightRightCone esah cone)).hom_ext
    ¬∑ exact (outer_pb (ofRightOuterCone esah cone)).fac_left
    ¬∑ rw! [Functor.assoc, wsah, ‚Üê Functor.assoc,
        (outer_pb (ofRightOuterCone esah cone)).fac_right, cone.comm_sq]
      simp
  fac_right := (outer_pb (ofRightOuterCone esah cone)).fac_right
  hom_ext hleft hright := by
    apply (outer_pb (ofRightOuterCone esah cone)).hom_ext
    ¬∑ rw [‚Üê Functor.assoc, hleft, Functor.assoc]
    ¬∑ exact hright

end

section
/-
           no           rth
  Algeria -----> Libya ----> Egypt
    |              |          |
  west         sah |          | east
    |              |          |
    V              V          V
  Niger   -----> Chad  ----> Sudan
           so           uth
-/
variable {Algeria : Type u} {Niger : Type*} [Category.{v} Algeria] [Category Niger]
  {north : Algeria ‚•§ Egypt} {rth : Libya ‚•§ Egypt}
  {west : Algeria ‚•§ Niger} {sah : Libya ‚•§ Chad} {east : Egypt ‚•§ Sudan}
  {so : Niger ‚•§ Chad} {uth : Chad ‚•§ Sudan}
  (outer : north ‚ãô east = west ‚ãô so ‚ãô uth) (esah : rth ‚ãô east = sah ‚ãô uth)
  (esah_pb : Œ† {C : Type u} [Category.{v} C] (cone : PullbackCone C east uth),
    Pullback (PullbackCone.mk _ _ esah) cone)
  (outer_pb : Œ† {C : Type u} [Category.{v} C] (cone : PullbackCone C east (so ‚ãô uth)),
    Pullback (PullbackCone.mk north west outer) cone)

variable {C : Type u} [Category.{v} C] (cone : PullbackCone C sah so)

@[simps] def ofRight'Outer : PullbackCone Algeria east uth where
  north := north
  west := west ‚ãô so
  comm_sq := outer

def ofRight'Lift : Algeria ‚•§ Libya := (esah_pb (ofRight'Outer outer)).lift

@[simps] def ofRight'OuterCone : PullbackCone Algeria east (so ‚ãô uth) where
  north := (ofRight'Lift outer esah esah_pb ‚ãô rth)
  west := west
  comm_sq := by
    convert outer
    convert (esah_pb (ofRight'Outer outer)).fac_left

def outer_pb' {C : Type u} [Category.{v} C] (cone : PullbackCone C east (so ‚ãô uth)) :
    Pullback (ofRight'OuterCone outer esah esah_pb) cone where
  lift := (outer_pb cone).lift
  fac_left := by
    convert (outer_pb cone).fac_left
    exact (esah_pb (ofRight'Outer outer)).fac_left
  fac_right := (outer_pb cone).fac_right
  hom_ext hl hr := by
    apply (outer_pb cone).hom_ext _ hr
    convert hl
    convert (esah_pb (ofRight'Outer outer)).fac_left.symm
    convert (esah_pb (ofRight'Outer outer)).fac_left.symm

/--
      ofRight'Lift
  Algeria -----> Libya
    |              |
  west         sah |
    |              |
    V              V
  Niger   -----> Chad
           so
-/
def ofRight'CommSq : (ofRight'Lift outer esah esah_pb) ‚ãô sah = west ‚ãô so :=
  (esah_pb (ofRight'Outer outer)).fac_right

/--
Pullback pasting <=,
where the map `no` is generated by the universal property of the right square
and the top map `north : Algberia ‚•§ Egypt`.
The left square is a pullback when the right and outer squares
are both pullbacks.
        ofRight'Lift    rth
  Algeria -----> Libya ----> Egypt
    |              |          |
  west         sah |          | east
    |              |          |
    V              V          V
  Niger   -----> Chad  ----> Sudan
           so           uth
-/
def ofRight' : Pullback (PullbackCone.mk (ofRight'Lift outer esah esah_pb) west
    (esah_pb (ofRight'Outer outer)).fac_right) cone :=
  ofRight _ esah esah_pb (outer_pb' _ _ _ outer_pb) cone

end

end Pullback

end


end CategoryTheory.Functor

namespace CategoryTheory.Cat

open Functor Limits

section
variable {Libya Egypt Chad Sudan : Type u} [Category.{v} Libya]
  [Category.{v} Egypt] [Category.{v} Chad] [Category.{v} Sudan]
  {north : Libya ‚•§ Egypt} {west : Libya ‚•§ Chad}
  {east : Egypt ‚•§ Sudan} {south : Chad ‚•§ Sudan}
  {comm_sq : north ‚ãô east = west ‚ãô south}
  (h : Œ† {C : Type u} [Category.{v} C] (cone : PullbackCone C east south),
      Pullback (PullbackCone.mk north west comm_sq) cone)
  (s : Limits.PullbackCone (homOf east) (homOf south))

def pullbackCone :
    Functor.PullbackCone s.pt east south where
  north := s.fst
  west := s.snd
  comm_sq := s.condition

def lift : s.pt ‚ü∂ of Libya := (h (pullbackCone s)).lift

def fac_left : lift h s ‚â´ (homOf north) = s.fst :=
  (h (pullbackCone s)).fac_left

def fac_right : lift h s ‚â´ (homOf west) = s.snd :=
  (h (pullbackCone s)).fac_right

def uniq (m : s.pt ‚ü∂ of Libya) (hl : m ‚â´ homOf north = s.fst)
    (hr : m ‚â´ homOf west = s.snd) : m = lift h s := by
  apply (h (pullbackCone s)).hom_ext
  ¬∑ convert (fac_left h s).symm
  ¬∑ convert (fac_right h s).symm

variable (comm_sq) in
def isPullback :
    IsPullback (homOf north) (homOf west) (homOf east)
    (homOf south) :=
  IsPullback.of_isLimit (PullbackCone.IsLimit.mk
    comm_sq (lift h) (fac_left _) (fac_right _) (uniq _))

end

end CategoryTheory.Cat
