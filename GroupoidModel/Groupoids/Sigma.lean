import GroupoidModel.Groupoids.NaturalModelBase
import GroupoidModel.Russell_PER_MS.NaturalModelSigma
import SEq.Tactic.DepRewrite

universe v u v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ v‚ÇÉ u‚ÇÉ

noncomputable section
-- NOTE temporary section for stuff to be moved elsewhere
section ForOther
open CategoryTheory NaturalModelBase Opposite Grothendieck.Groupoidal

namespace CategoryTheory

namespace Grpd

@[simp] theorem id_obj {C : Grpd} (X : C) :
    (ùüô C : C ‚•§ C).obj X = X :=
  rfl

@[simp] theorem comp_obj {C D E : Grpd} (F : C ‚ü∂ D) (G : D ‚ü∂ E)
    (X : C) : (F ‚â´ G).obj X = G.obj (F.obj X) :=
  rfl

variable {Œì : Type u} [Category.{v} Œì] (F : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ})

@[simp] theorem map_eqToHom_obj {x y : Œì} (h : x = y) (t) :
    (F.map (eqToHom h)).obj t = cast (by rw [h]) t := by
  subst h
  simp

-- set_option pp.proofs true
@[simp] theorem map_eqToHom_map {x y : Œì} (h : x = y) {t s} (f : t ‚ü∂ s) :
    (F.map (eqToHom h)).map f =
    eqToHom (Functor.congr_obj (eqToHom_map _ _) t)
    ‚â´ cast (Grpd.eqToHom_hom_aux t s (by rw [h])) f
    ‚â´ eqToHom (Eq.symm (Functor.congr_obj (eqToHom_map _ _) s)) := by
  have h1 : F.map (eqToHom h) = eqToHom (by rw [h]) := eqToHom_map _ _
  rw [Functor.congr_hom h1, Grpd.eqToHom_hom]

end Grpd

namespace Grothendieck

namespace Groupoidal

variable {C : Type u} [Category.{v, u} C] {F : C ‚•§ Grpd} {X Y : C}

@[simp] lemma sec_map_base {Œ± : C ‚•§ PGrpd.{v‚ÇÅ,u‚ÇÅ}} {x y} {f : x ‚ü∂ y} :
    ((Grothendieck.Groupoidal.sec Œ±).map f).base = f := by
  simp [Grothendieck.Groupoidal.sec, Grothendieck.Groupoidal.sec',
            IsMegaPullback.lift, Grothendieck.IsMegaPullback.lift]

@[simp] lemma sec_map_fiber {Œ± : C ‚•§ PGrpd.{v‚ÇÅ,u‚ÇÅ}} {x y} {f : x ‚ü∂ y} :
    ((Grothendieck.Groupoidal.sec Œ±).map f).fiber = (Œ±.map f).point := by
  simp [Grothendieck.Groupoidal.sec, Grothendieck.Groupoidal.sec',
            IsMegaPullback.lift, Grothendieck.IsMegaPullback.lift,
            Grothendieck.IsMegaPullback.lift_map,
            Grothendieck.IsMegaPullback.point]

@[simp] theorem ŒπNatTrans_app_base
    (f : X ‚ü∂ Y) (d : ‚Üë(F.obj X)) : ((ŒπNatTrans f).app d).base = f :=
  Grothendieck.ŒπNatTrans_app_base _ _

@[simp] theorem ŒπNatTrans_app_fiber (f : X ‚ü∂ Y) (d : F.obj X) :
    ((ŒπNatTrans f).app d).fiber
    = ùüô ((F.map f).obj ((Groupoidal.Œπ F X).obj d).fiber) :=
  Grothendieck.ŒπNatTrans_app_fiber _ _

end Groupoidal

end Grothendieck

end CategoryTheory

end ForOther

-- NOTE content for this doc starts here
namespace GroupoidModel

open CategoryTheory NaturalModelBase Opposite Grothendieck.Groupoidal

notation:max "@(" Œì ")" => Ctx.toGrpd.obj Œì

namespace FunctorOperation

section
variable {Œì : Type u‚ÇÇ} [Category.{v‚ÇÇ} Œì] {A : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}}
    (B : ‚à´(A) ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}) (x : Œì)
/--
For a point `x : Œì`, `(sigma A B).obj x` is the groupoidal Grothendieck
  construction on the composition
  `Œπ _ x ‚ãô B : A.obj x ‚•§ Groupoidal A ‚•§ Grpd`
-/
@[simp, reducible] def sigmaObj := ‚à´(Œπ A x ‚ãô B)

variable {x} {y : Œì} (f : x ‚ü∂ y)
/--
For a morphism `f : x ‚ü∂ y` in `Œì`, `(sigma A B).map y` is a
composition of functors.
The first functor `map (whiskerRight (ŒπNatTrans f) B)`
is an equivalence which replaces `Œπ A x` with the naturally
isomorphic `A.map f ‚ãô Œπ A y`.
The second functor is the action of precomposing
`A.map f` with `Œπ A y ‚ãô B` on the Grothendieck constructions.

            map ‚ãØ                  pre ‚ãØ
  ‚à´ Œπ A x ‚ãô B ‚•§ ‚à´ A.map f ‚ãô Œπ A y ‚ãô B ‚•§ ‚à´ Œπ A y ‚ãô B
-/
def sigmaMap : sigmaObj B x ‚•§ sigmaObj B y :=
  map (whiskerRight (ŒπNatTrans f) B) ‚ãô pre (Œπ A y ‚ãô B) (A.map f)

variable {B}

@[simp] theorem sigmaMap_id_obj {p} : (sigmaMap B (ùüô x)).obj p = p := by
  simp only [sigmaMap, Functor.comp_obj, map_obj, Functor.id_obj]
  apply obj_ext_hEq
  ¬∑ rw [pre_obj_base, Grpd.map_id_obj]
  ¬∑ simp

@[simp] theorem sigmaMap_id_map {p1 p2} (f : p1 ‚ü∂ p2) :
    (sigmaMap B (ùüô x)).map f =
    eqToHom (by simp) ‚â´ f ‚â´ eqToHom (by simp) := by
  let t := @ŒπNatTrans _ _ A _ _ (CategoryStruct.id x)
  have h (a : A.obj x) : B.map (t.app a) =
      eqToHom (by simp [Functor.map_id]) :=
    calc
      B.map (t.app a)
      _ = B.map (eqToHom (by simp [Functor.map_id])) := by
        rw [ŒπNatTrans_id_app]
      _ = eqToHom (by simp [Functor.map_id]) := by
        simp [eqToHom_map]
  dsimp only [sigmaMap]
  simp only [Functor.comp_map, Functor.id_map]
  apply Grothendieck.Groupoidal.ext
  ¬∑ simp only [pre_map_fiber, map_map_fiber, whiskerRight_app, eqToHom_trans_assoc, comp_fiber, eqToHom_fiber, eqToHom_map]
    -- NOTE rw! much faster here for map_eqToHom_map and Functor.congr_hom
    rw! [Functor.congr_hom (h p2.base) f.fiber, eqToHom_base,
      Grpd.map_eqToHom_map, Grpd.eqToHom_hom]
    -- NOTE Œπ_obj, Œπ_map really unhelpful when there is an eqToHom
    simp only [Category.assoc, eqToHom_trans, eqToHom_trans_assoc]
  ¬∑ simp

theorem sigmaMap_id : sigmaMap B (CategoryStruct.id x) = Functor.id _ := by
    apply CategoryTheory.Functor.ext
    ¬∑ intro p1 p2 f
      simp
    ¬∑ intro p
      simp

variable {z : Œì} {f} {g : y ‚ü∂ z}

@[simp] theorem sigmaMap_comp_obj {p} : (sigmaMap B (f ‚â´ g)).obj p =
    (sigmaMap B g).obj ((sigmaMap B f).obj p) := by
  dsimp only [sigmaMap]
  apply obj_ext_hEq
  ¬∑ simp
  ¬∑ simp

@[simp] theorem sigmaMap_comp_map {A : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}}
    {B : ‚à´(A) ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}} {x y z : Œì} {f : x ‚ü∂ y} {g : y ‚ü∂ z}
    {p q} (hpq : p ‚ü∂ q) {h1} {h2} :
    (sigmaMap B (f ‚â´ g)).map hpq =
    eqToHom h1 ‚â´ (sigmaMap B g).map ((sigmaMap B f).map hpq) ‚â´ eqToHom h2 := by
  -- let t := B.map ((ŒπNatTrans (f ‚â´ g)).app q.base)
  have h : B.map ((ŒπNatTrans (f ‚â´ g)).app q.base) =
    B.map ((ŒπNatTrans f).app q.base)
    ‚â´ B.map ((ŒπNatTrans g).app ((A.map f).obj q.base))
    ‚â´ eqToHom (by simp) := by simp [eqToHom_map]
  dsimp only [sigmaMap]
  apply Grothendieck.Groupoidal.ext
  ¬∑ have h3 : (Œπ A z ‚ãô B).map (eqToHom h2).base
        = eqToHom (by simp [sigmaMap]) := by
      rw [eqToHom_base, eqToHom_map]
    conv =>
      right
      simp only [comp_fiber, eqToHom_fiber, eqToHom_map]
      rw! [Functor.congr_hom h3]
    conv =>
      left
      -- NOTE with rw this will timeout
      rw! [map_map_fiber]
      -- simp only [eqToHom_trans_assoc]
      simp only [Functor.comp_obj, map_obj, whiskerRight_app, Functor.comp_map,
        pre_map_base, map_map_base]
      -- NOTE not sure what some of these simp lemmas are doing,
      -- but when present, rw! [h] works
      -- NOTE with rw this will timeout
      rw! [Functor.congr_hom h]
      simp only [Grpd.comp_eq_comp, Functor.comp_map, Grpd.eqToHom_hom]
    apply eq_of_heq
    simp only [Functor.comp_map, eqToHom_trans_assoc, pre_map_fiber,
      map_map_fiber, Functor.map_comp, eqToHom_map, Grpd.eqToHom_hom,
      Category.assoc, eqToHom_trans, heq_eqToHom_comp_iff,
      eqToHom_comp_heq_iff, comp_eqToHom_heq_iff,
      heq_comp_eqToHom_iff, cast_heq_iff_heq]
    simp only [Functor.comp_obj, id_eq, pre_obj_base, Grpd.comp_eq_comp,
      map_obj, whiskerRight_app, Functor.comp_map, heq_cast_iff_heq,
      heq_eqToHom_comp_iff, heq_eq_eq]
  ¬∑ simp

theorem sigmaMap_comp :
    sigmaMap B (f ‚â´ g) = sigmaMap B f ‚ãô sigmaMap B g := by
  apply CategoryTheory.Functor.ext
  ¬∑ intro p q hpq
    simp
  ¬∑ intro p
    simp

/-- The formation rule for Œ£-types for the ambient natural model `base`
  unfolded into operations between functors.
  See `sigmaObj` and `sigmaMap` for the actions of this functor.
 -/
@[simps] def sigma (A : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ})
    (B : ‚à´(A) ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}) : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ} where
  -- NOTE using Grpd.of here instead of earlier speeds things up
  obj x := Grpd.of $ sigmaObj B x
  map := sigmaMap B
  map_id _ := sigmaMap_id
  map_comp _ _ := sigmaMap_comp

variable {Œî : Type u‚ÇÉ} [Category.{v‚ÇÉ} Œî] (œÉ : Œî ‚•§ Œì)

theorem sigmaBeckChevalley : œÉ ‚ãô sigma A B = sigma (œÉ ‚ãô A) (pre A œÉ ‚ãô B) := by
  refine CategoryTheory.Functor.ext ?_ ?_
  . intros x
    dsimp only [Functor.comp_obj, sigma_obj, sigmaObj]
    rw! [‚Üê ŒπCompPre œÉ A x]
    rfl
  . intros x y f
    sorry -- this goal might be improved by adding API for Groupoidal.Œπ and Groupoidal.pre

end

section

variable {Œì : Type u‚ÇÇ} [Category.{v‚ÇÇ} Œì] {Œ± Œ≤ : Œì ‚•§ PGrpd.{v‚ÇÅ,u‚ÇÅ}}
  {B : ‚à´(Œ± ‚ãô PGrpd.forgetToGrpd) ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}}
  (h : Œ≤ ‚ãô PGrpd.forgetToGrpd = sec Œ± ‚ãô B)

def pairSectionObj (x : Œì) :
    ‚à´(sigma (Œ± ‚ãô PGrpd.forgetToGrpd) B) :=
  ‚ü® x, (Œ±.obj x).str.pt, PGrpd.compForgetToGrpdObjPt h x ‚ü©

def pairSectionMap {x y} (f : x ‚ü∂ y) :
    pairSectionObj h x ‚ü∂ pairSectionObj h y :=
    have := by
      -- NOTE Not sure how we can make this goal more readable
      simp only [Functor.comp_obj, Grpd.forgetToCat.eq_1,
        sigma_obj, sigmaObj, Functor.comp_map, sigma_map, sigmaMap,
        PGrpd.forgetToGrpd_map, id_eq, map_obj,
        whiskerRight_app, pre_obj_base, pre_obj_fiber]
      rw [‚Üê Grpd.map_comp_obj]
      congr 3
      apply Grothendieck.Groupoidal.ext
      ¬∑ simp [Œπ_map]
      ¬∑ simp [Œπ_map]
    ‚ü® f, (Œ±.map f).point, eqToHom this ‚â´ PGrpd.compForgetToGrpdMapPoint h f ‚ü©

@[simp] theorem pairSection_map_id_base (x) :
    (pairSectionMap h (CategoryStruct.id x)).base = CategoryStruct.id x := by
  simp [pairSectionMap]

-- NOTE these simp lemmas from mathlib should maybe be removed
-- Grpd.forgetToCat...?

@[simp] theorem pairSection_map_id_fiber (x) :
    (pairSectionMap h (CategoryStruct.id x)).fiber
    = eqToHom (by simp [pairSectionObj]):= by
  apply Grothendieck.Groupoidal.ext
  ¬∑ simp [pairSectionMap]
  ¬∑ simp [pairSectionMap]

theorem pairSection_map_id (x) :
    pairSectionMap h (CategoryStruct.id x) = CategoryStruct.id _ := by
  apply Grothendieck.ext
  ¬∑ simp
  ¬∑ rfl

theorem pairSection_map_comp {x y z} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    pairSectionMap _ (f ‚â´ g) = pairSectionMap h f ‚â´ pairSectionMap h g := by
  apply Grothendieck.ext
  ¬∑ simp [pairSectionMap]
    sorry
  ¬∑ simp [pairSectionMap]

def pairSection : Œì ‚•§ ‚à´(sigma (Œ± ‚ãô PGrpd.forgetToGrpd) B) where
    obj := pairSectionObj h
    map {x y} := pairSectionMap h
    map_id := pairSection_map_id _
    map_comp f g := by
      convert_to pairSectionMap _ (f ‚â´ g) = pairSectionMap _ f ‚â´ pairSectionMap _ g
      sorry
      -- fapply Grothendieck.ext
      -- . rfl
      -- . dsimp
      --   simp only [Category.id_comp]
      --   ¬∑ apply Grothendieck.ext
          -- . -- simp only [Œπ, Grpd.forgetToCat, Functor.comp_obj, Grothendieck.Œπ_obj, Cat.of_Œ±, Grpd.coe_of, id_eq,
            --   Grothendieck.ŒπNatTrans, PGrpd.forgetToGrpd_obj, Functor.comp_map,
            --   PGrpd.forgetToGrpd_map, map, whiskerRight_twice,
            --   Grothendieck.Groupoidal.pre, Grothendieck.pre_obj_base, Grothendieck.map_obj_base, Grothendieck.Œπ_map,
            --   Grothendieck.pre_obj_fiber, Grothendieck.map_obj_fiber, whiskerRight_app, Grpd.forgetToGrpdMapPoint,
            --   Grothendieck.comp_base, Grothendieck.pre_map_base, Grothendieck.map_map_base, eqToHom_trans_assoc,
            --   Grothendieck.comp_fiber, Grothendieck.fiber_eqToHom, eqToHom_map, Grothendieck.pre_map_fiber,
            --   Grothendieck.map_map_fiber, Functor.map_comp, Category.assoc]
            -- have h3 : Œ≤.map (f ‚â´ g) = _ := Functor.map_comp _ _ _
            -- have h4 : Grpd.homOf (Œ≤.map g).toFunctor = _ := Functor.congr_hom h g
            -- simp only [Grpd.homOf] at h4
            -- simp only [PointedFunctor.congr_point h3, PGrpd.comp_toFunctor, Functor.comp_obj, PGrpd.comp_point,
            --   Category.assoc]
            -- rw [Functor.congr_hom h4 (Œ≤.map f).point]
            -- simp only [Grpd.comp_eq_comp, Functor.map_comp]
            -- simp only [eqToHom_map]
            -- simp only [Grothendieck.Groupoidal.sec, IsMegaPullback.lift,
            --   Grothendieck.IsMegaPullback.lift, Grothendieck.IsMegaPullback.lift_map]
            -- sorry
          -- . sorry --simp [Grpd.forgetToCat, Grothendieck.Groupoidal.pre, map, PGrpd.map_comp_point]

theorem pairSection_comp_forget :
    (pairSection h) ‚ãô Grothendieck.forget _ = Functor.id Œì :=
  rfl

def pair : Œì ‚•§ PGrpd.{v‚ÇÅ,u‚ÇÅ} := pairSection h ‚ãô toPGrpd _

theorem pair_comp_forget :
    pair h ‚ãô PGrpd.forgetToGrpd = sigma (Œ± ‚ãô PGrpd.forgetToGrpd) B := by
  unfold pair
  rw [Functor.assoc]
  exact rfl

end

variable {Œì : Type u‚ÇÇ} [Category.{v‚ÇÇ} Œì] {A : Œì ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}}
    (B : ‚à´(A) ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}) (x : Œì)

def fstAux : sigma A B ‚ü∂ A where
  app x := Grpd.homOf (Grothendieck.forget _)

def fst : ‚à´(sigma A B) ‚•§ ‚à´(A) :=
  map (fstAux B)

-- JH: changed name from `snd` to `assoc`
-- maybe we should use `Grothendieck.functorFrom`
def assoc : ‚à´(sigma A B) ‚•§ ‚à´(B) := sorry

def snd : ‚à´(sigma A B) ‚•§ PGrpd :=
  assoc B ‚ãô toPGrpd B

-- set_option maxHeartbeats 0 in
-- def snd {Œì : Grpd} (A : Œì ‚•§ Cat.of Grpd.{v‚ÇÅ,u‚ÇÅ})
--     (B : Grothendieck.Groupoidal A ‚•§ Grpd.{v‚ÇÅ,u‚ÇÅ}) :
--   Grothendieck.Groupoidal (sigma A B) ‚•§  Grothendieck.Groupoidal B where
--   obj x := by
--     rcases x with ‚ü®base,fiber,fiberfiber‚ü©
--     fconstructor
--     fconstructor
--     . exact base
--     . exact fiber
--     . exact fiberfiber
--   map {x y} f := by
--     rcases f with ‚ü®base,fiber,fiberfiber‚ü©
--     fconstructor
--     fconstructor
--     . exact base
--     . exact fiber
--     . refine eqToHom ?_ ‚â´ fiberfiber
--       . simp[Grpd.forgetToCat,Grothendieck.Groupoidal.pre,whiskerRight,map]
--         set I := ((Œπ A y.base).map fiber)
--         set J := (@Grothendieck.ŒπNatTrans (‚ÜëŒì) Groupoid.toCategory (Groupoid.compForgetToCat A) x.base y.base base).app x.fiber.base
--         have eq1 : (B.map I).obj ((B.map J).obj x.fiber.fiber) = (B.map J ‚â´ B.map I).obj x.fiber.fiber := rfl
--         rw [eq1,<- B.map_comp J I]
--         simp[J,I,CategoryStruct.comp,Grothendieck.comp,Œπ]
--         refine Functor.congr_obj ?_ x.fiber.fiber
--         refine congrArg B.map ?_
--         apply Grothendieck.ext
--         . simp
--         . simp
--   map_id := by
--     intro x
--     simp[Grothendieck.Hom.rec,Grothendieck.Hom.rec]
--     sorry
--   map_comp := sorry

def ABToAlpha : ‚à´(sigma A B) ‚•§ PGrpd :=
  fst B ‚ãô toPGrpd A

def ABToB : ‚à´(ABToAlpha B ‚ãô PGrpd.forgetToGrpd) ‚•§ Grpd := by
  refine ?_ ‚ãô fst B ‚ãô B
  exact Grothendieck.forget (Groupoid.compForgetToCat (ABToAlpha B ‚ãô PGrpd.forgetToGrpd))

def ABToBeta : ‚à´(sigma A B) ‚•§ PGrpd :=
  assoc B ‚ãô (Grothendieck.Groupoidal.toPGrpd B)

end FunctorOperation

open FunctorOperation

/-- The formation rule for Œ£-types for the ambient natural model `base` -/
def baseSig : base.Ptp.obj base.{u}.Ty ‚ü∂ base.Ty where
  app Œì := fun p =>
    let ‚ü®A,B‚ü© := baseUvPolyTpEquiv p
    yonedaEquiv (yonedaCatEquiv.symm (sigma A B))
  naturality := sorry -- do not attempt

def basePair : base.uvPolyTp.compDom base.uvPolyTp ‚ü∂ base.Tm where
  app Œì := fun Œµ =>
    let ‚ü®Œ±,B,Œ≤,h‚ü© := baseUvPolyTpCompDomEquiv Œµ
    yonedaEquiv (yonedaCatEquiv.symm (pair h))
  naturality := by sorry

def Sigma_Comm : basePair ‚â´ base.tp = (base.uvPolyTp.comp base.uvPolyTp).p ‚â´ baseSig := by sorry

def PairUP' {Œì : Ctx.{u}} (AB : yoneda.obj Œì ‚ü∂ base.Ptp.obj base.{u}.Ty) :
    yoneda.obj (base.ext (AB ‚â´ baseSig)) ‚ü∂ base.uvPolyTp.compDom base.uvPolyTp := by
  -- sorry
  refine yonedaEquiv.invFun ?_
  refine baseUvPolyTpCompDomEquiv.invFun ?_
  let AB' := baseUvPolyTpEquiv (yonedaEquiv.toFun AB)
  exact ‚ü®ABToAlpha AB'.snd, ABToB AB'.snd, ABToBeta AB'.snd, by
    -- simp
    sorry
  ‚ü©

-- NOTE this has been refactored through sec'
-- def GammaToSigma {Œì : Ctx} (top : (yoneda.obj Œì) ‚ü∂ base.Tm)
--     (left : (yoneda.obj Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty)
--     (h : top ‚â´ base.tp = left ‚â´ baseSig) :
--     (yoneda.obj Œì) ‚ü∂ yoneda.obj (base.ext (left ‚â´ baseSig)) :=
--   (base.disp_pullback (left ‚â´ baseSig)).lift top (ùüô _) (by rw[Category.id_comp,h])

-- def GammaToSigmaInv_disp {Œì : Ctx} (top : (yoneda.obj Œì) ‚ü∂ base.Tm) (left : (yoneda.obj Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty) (h : top ‚â´ base.tp = left ‚â´ baseSig) : (base.sec' top _ h) ‚â´ (yoneda.map (base.disp (left ‚â´ baseSig))) = ùüô (yoneda.obj Œì) := by
--   simp [sec']

def PairUP {Œì : Ctx} (top : (yoneda.obj Œì) ‚ü∂ base.Tm)
    (left : (yoneda.obj Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty)
    (h : top ‚â´ base.tp = left ‚â´ baseSig) :
    (yoneda.obj Œì) ‚ü∂ base.uvPolyTp.compDom base.uvPolyTp :=
  base.sec' h ‚â´ (PairUP' left)

namespace SigmaPullback

def somethingEquiv' {Œì : Ctx} {ab : y(Œì) ‚ü∂ base.Tm}
  (A : (Ctx.toGrpd.obj Œì) ‚•§ Grpd.{u,u})
  (B : ‚à´(A) ‚•§ Grpd.{u,u})
  (sigAB : ‚Üë(Ctx.toGrpd.obj Œì) ‚•§ Grpd.{u,u})
  (ab : Ctx.toGrpd.obj Œì ‚•§ PGrpd.{u,u})
  (h : ab ‚ãô PGrpd.forgetToGrpd = sigAB) :
  (Œ± : Ctx.toGrpd.obj Œì ‚•§ PGrpd.{u,u}) √ó'
  (Œ± ‚ãô PGrpd.forgetToGrpd = A) := sorry

theorem yonedaCatEquiv_baseSig {Œì : Ctx} {A : Ctx.toGrpd.obj Œì ‚•§ Grpd.{u,u}}
    {B : ‚à´(A) ‚•§ Grpd.{u,u}} :
    yonedaCatEquiv ((baseUvPolyTpEquiv'.symm ‚ü®A,B‚ü©) ‚â´ baseSig) = sigma A B
    := by
  simp only [yonedaCatEquiv, Equiv.trans_apply, yonedaEquiv_comp, baseSig, Equiv.symm_trans_apply, Equiv.toFun_as_coe, baseUvPolyTpEquiv]
  rw [yonedaCatEquivAux.apply_eq_iff_eq_symm_apply,
    yonedaEquiv.apply_eq_iff_eq_symm_apply,
    Equiv.symm_apply_apply, Equiv.apply_symm_apply]
  congr

def somethingEquiv {Œì : Ctx} {ab : y(Œì) ‚ü∂ base.Tm}
    {AB : y(Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty}
    (h : ab ‚â´ base.tp = AB ‚â´ baseSig)
    : (A : Ctx.toGrpd.obj Œì ‚•§ Grpd.{u,u})
    √ó (Œ± : Ctx.toGrpd.obj Œì ‚•§ PGrpd.{u,u})
    √ó (B : ‚à´(A) ‚•§ Grpd.{u,u})
    √ó (Œ≤ : Ctx.toGrpd.obj Œì ‚•§ PGrpd.{u,u})
    √ó' (h : Œ± ‚ãô PGrpd.forgetToGrpd = A)
    √ó' Œ≤ ‚ãô PGrpd.forgetToGrpd = Grothendieck.Groupoidal.sec Œ± ‚ãô Grothendieck.Groupoidal.map (eqToHom h) ‚ãô B :=
  let AB' := baseUvPolyTpEquiv (yonedaEquiv AB)
  let A := AB'.1
  let B := AB'.2
  let h1 := baseTmEquiv ‚ü®AB ‚â´ baseSig,ab,h‚ü©
  let sigAB := h1.1
  let ab' := h1.2.1
  let hab := h1.2.2
  have h2 : ab' ‚ãô PGrpd.forgetToGrpd = sigma AB'.fst B := by
      rw [hab, baseTmEquiv_fst, ‚Üê yonedaCatEquiv_baseSig, Sigma.eta]
      simp [AB', baseUvPolyTpEquiv]
  let Œ± := sec ab' ‚ãô map (eqToHom h2) ‚ãô fst B ‚ãô toPGrpd A
  ‚ü® A,
    Œ±,
    B,
    sorry,
    sorry,
    sorry ‚ü©

-- strategy: want to first show that cones of the diagram
-- correspond to some functor data,
-- then do the functor constructions
def lift {Œì : Ctx} {ab : y(Œì) ‚ü∂ base.Tm}
    {AB : y(Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty}
    (h : ab ‚â´ base.tp = AB ‚â´ baseSig) :
    (yoneda.obj Œì) ‚ü∂ base.uvPolyTp.compDom base.uvPolyTp :=
  yonedaEquiv.invFun $
  baseUvPolyTpCompDomEquiv'.invFun
  (somethingEquiv h)

end SigmaPullback

theorem PairUP_Comm1' {Œì : Ctx} (top : (yoneda.obj Œì) ‚ü∂ base.Tm) (left : (yoneda.obj Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty) (h : top ‚â´ base.tp = left ‚â´ baseSig) : PairUP' left ‚â´ basePair = (yoneda.map (base.disp (left ‚â´ baseSig))) ‚â´ top := by
  sorry

theorem PairUP_Comm1 {Œì : Ctx} (top : (yoneda.obj Œì) ‚ü∂ base.Tm) (left : (yoneda.obj Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty) (h : top ‚â´ base.tp = left ‚â´ baseSig) : (PairUP top left h) ‚â´ basePair = top := by
  unfold PairUP
  rw[Category.assoc,PairUP_Comm1' top left h,<- Category.assoc,
    sec'_disp,Category.id_comp]

theorem PairUP_Comm2' {Œì : Ctx} (top : (yoneda.obj Œì) ‚ü∂ base.Tm) (left : (yoneda.obj Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty) (h : top ‚â´ base.tp = left ‚â´ baseSig) : PairUP' left ‚â´ (base.uvPolyTp.comp base.uvPolyTp).p = (yoneda.map (base.disp (left ‚â´ baseSig))) ‚â´ left := by
  sorry

theorem PairUP_Comm2 {Œì : Ctx} (top : (yoneda.obj Œì) ‚ü∂ base.Tm)
    (left : (yoneda.obj Œì) ‚ü∂ base.Ptp.obj base.{u}.Ty)
    (h : top ‚â´ base.tp = left ‚â´ baseSig) :
    (PairUP top left h) ‚â´ (base.uvPolyTp.comp base.uvPolyTp).p = left
    := by
  unfold PairUP
  rw[Category.assoc,PairUP_Comm2' top left h,<- Category.assoc,
    sec'_disp,Category.id_comp]

theorem PairUP_Uniqueness {Œì : Ctx}
    (f : (yoneda.obj Œì) ‚ü∂ base.uvPolyTp.compDom base.uvPolyTp) :
    f = (PairUP (f ‚â´  basePair)
      (f ‚â´ (base.uvPolyTp.comp base.uvPolyTp).p)
      (by rw[Category.assoc,Category.assoc]; congr 1; exact Sigma_Comm))     := by
  unfold PairUP
  refine (base.uvPolyTpCompDomEquiv Œì).injective ?_
  refine Sigma.ext ?_ ?_
  . sorry
  . sorry

def is_pb : IsPullback basePair (base.uvPolyTp.comp base.uvPolyTp).p base.tp baseSig := by
  sorry

def baseSigma : NaturalModelSigma base where
  Sig := baseSig
  pair := basePair
  Sig_pullback := is_pb

def smallUSigma : NaturalModelSigma smallU := sorry

def uHomSeqSigmas' (i : ‚Ñï) (ilen : i < 4) :
  NaturalModelSigma (uHomSeqObjs i ilen) :=
  match i with
  | 0 => smallUSigma
  | 1 => smallUSigma
  | 2 => smallUSigma
  | 3 => baseSigma
  | (n+4) => by omega

end GroupoidModel
end
